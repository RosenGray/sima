---
description: Filter implementation guidelines for listing pages (business logic, database, UI)
globs:
alwaysApply: true
---

# Filter Implementation Guidelines

## Overview

This guide covers implementing filters for listing pages, including search params processing, repository filtering, database queries, and UI components. Filters should be implemented step by step: first backend/database logic, then UI components.

## Implementation Steps

### Step 1: Define Filter Types

1. **Create filter interface in repository file:**
   ```typescript
   export interface EntitySearchFilters {
     filterParam1?: string[];
     filterParam2?: string[];
     numericFilter?: string[]; // For range filters like yearFrom/yearTo
   }
   ```

2. **Add filter params to page searchParams interface:**
   ```typescript
   interface EntityPageProps {
     searchParams?: Promise<{
       filterParam1?: string | string[];
       filterParam2?: string | string[];
       numericFilter?: string; // For single value filters like yearFrom
       page?: string;
     }>;
   }
   ```

### Step 2: Process Search Params to Filters

1. **Extract filters from searchParams** (handled in page component):
   ```typescript
   const filters = searchParamsToFilters(searchParams);
   ```

2. **Use `searchParamsToFilters` utility** from `@/utils/common`:
   - Automatically converts `string | string[]` to `string[]`
   - Excludes `page` by default
   - Filters out empty/undefined values

### Step 3: Update Repository getAll Method

#### Method Signature

```typescript
async getAll(
  searchFilters: EntitySearchFilters = {},
  currentPage: number = 1,
  pageSize: number = 10
): Promise<PaginatedResponse>
```

#### Implementation Pattern

1. **Add filter interface and update method signature**

2. **Sanitize filters** (prevent NoSQL injection):
   ```typescript
   import sanitize from "mongo-sanitize";
   
   const sanitizedFilters: EntitySearchFilters = {
     filterParam1: sanitize(searchFilters.filterParam1),
     filterParam2: sanitize(searchFilters.filterParam2),
   };
   ```

3. **Build MongoDB query filter:**
   ```typescript
   const searchFilter: FilterQuery<typeof Entity> = {};
   ```

4. **Add filter conditions:**
   
   **For string array filters (multiple selection):**
   ```typescript
   if (sanitizedFilters.filterParam1) {
     searchFilter.filterParam1 = { $in: sanitizedFilters.filterParam1 };
   }
   ```
   
   **For ObjectId array filters (with validation):**
   ```typescript
   if (sanitizedFilters.categoryId) {
     const isValidObjectId = sanitizedFilters.categoryId.every((id) => 
       mongoose.Types.ObjectId.isValid(id)
     );
     if (isValidObjectId) {
       searchFilter.category = { $in: sanitizedFilters.categoryId };
     } else {
       // Invalid ObjectId - return empty results
       searchFilter._id = new mongoose.Types.ObjectId();
     }
   }
   ```
   
   **For numeric range filters (yearFrom/yearTo):**
   ```typescript
   // Handle yearFrom (single value, not array)
   if (sanitizedFilters.yearFrom) {
     const yearFromNum = Number(sanitizedFilters.yearFrom);
     if (!Number.isNaN(yearFromNum)) {
       searchFilter.yearOfManufacture = { $gte: yearFromNum };
     }
   }
   
   // Handle yearTo (single value, not array)
   if (sanitizedFilters.yearTo) {
     const yearToNum = Number(sanitizedFilters.yearTo);
     if (!Number.isNaN(yearToNum)) {
       // Combine with existing yearOfManufacture filter if exists
       searchFilter.yearOfManufacture = {
         ...searchFilter.yearOfManufacture,
         $lte: yearToNum,
       };
     }
   }
   ```
   
   **For enum filters:**
   ```typescript
   if (sanitizedFilters.district) {
     searchFilter.district = { $in: sanitizedFilters.district };
   }
   ```

5. **Use filter in query:**
   ```typescript
   const totalCount = await Entity.countDocuments(searchFilter);
   const results = await Entity.find(searchFilter)
     .populate("user")
     .sort({ createdAt: -1 })
     .skip(skip)
     .limit(pageSize);
   ```

### Step 4: Update Content Component

1. **Update filter interface to match repository:**
   ```typescript
   interface EntityContentProps {
     filters: EntitySearchFilters;
     currentPage: number;
   }
   ```

2. **Pass filters to repository:**
   ```typescript
   const entityResponse = await entityRepository.getAll(
     filters,
     currentPage,
     10
   );
   ```

### Step 5: Update Page Component

1. **Add filter params to searchParams interface**

2. **Import filter type from repository:**
   ```typescript
   import { EntitySearchFilters } from "@/lib/{category}/{entity}/repository/{Entity}Repository";
   ```

3. **Process filters using utility:**
   ```typescript
   // Extract array filters using utility
   const arrayFilters = searchParamsToFilters(searchParams);
   
   // Build filters object with proper types
   const filters: EntitySearchFilters = {
     manufacturer: arrayFilters.manufacturer,
     model: arrayFilters.model,
     // Add other array filters here
   };
   ```

4. **Handle special cases (single value filters like yearFrom/yearTo):**
   ```typescript
   // Handle yearFrom and yearTo as single values (not arrays) for range queries
   if (searchParams.yearFrom) {
     filters.yearFrom = Array.isArray(searchParams.yearFrom) 
       ? searchParams.yearFrom[0] 
       : searchParams.yearFrom;
   }
   
   if (searchParams.yearTo) {
     filters.yearTo = Array.isArray(searchParams.yearTo) 
       ? searchParams.yearTo[0] 
       : searchParams.yearTo;
   }
   ```

5. **Pass filters to content component:**
   ```typescript
   <EntityContent filters={filters} currentPage={currentPage} />
   ```

## Filter Types

### 1. String Array Filters (Multiple Selection)

**Use case:** Multiple values can be selected (e.g., manufacturer, model, district)

**Example:** `manufacturer: ["Toyota", "Honda", "BMW"]`

**Implementation:**
```typescript
// Interface
manufacturer?: string[];

// Query
if (sanitizedFilters.manufacturer) {
  searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
}
```

### 2. ObjectId Array Filters

**Use case:** Filtering by referenced entities (e.g., categoryId, subCategoryId)

**Example:** `categoryId: ["507f1f77bcf86cd799439011", "507f191e810c19729de860ea"]`

**Implementation:**
```typescript
// Interface
categoryId?: string[];

// Query with validation
if (sanitizedFilters.categoryId) {
  const isValidObjectId = sanitizedFilters.categoryId.every((id) => 
    mongoose.Types.ObjectId.isValid(id)
  );
  if (isValidObjectId) {
    searchFilter.category = { $in: sanitizedFilters.categoryId };
  } else {
    // Invalid ObjectId - return empty results
    searchFilter._id = new mongoose.Types.ObjectId();
  }
}
```

### 3. Numeric Range Filters (Single Value)

**Use case:** Range queries for numeric fields (e.g., yearFrom, yearTo, priceFrom, priceTo)

**Example:** `yearFrom: "2020"`, `yearTo: "2024"`

**Implementation:**
```typescript
// Interface - single string value, not array
yearFrom?: string;
yearTo?: string;

// Query - combine with $gte and $lte
if (sanitizedFilters.yearFrom) {
  const yearFromNum = Number(sanitizedFilters.yearFrom);
  if (!Number.isNaN(yearFromNum)) {
    searchFilter.yearOfManufacture = { $gte: yearFromNum };
  }
}

if (sanitizedFilters.yearTo) {
  const yearToNum = Number(sanitizedFilters.yearTo);
  if (!Number.isNaN(yearToNum)) {
    searchFilter.yearOfManufacture = {
      ...searchFilter.yearOfManufacture,
      $lte: yearToNum,
    };
  }
}
```

### 4. Enum Filters

**Use case:** Filtering by enum values (e.g., district, transmission, engineType)

**Example:** `district: ["Center", "North"]`

**Implementation:**
```typescript
// Interface
district?: string[];

// Query
if (sanitizedFilters.district) {
  searchFilter.district = { $in: sanitizedFilters.district };
}
```

### 5. Text Search Filters (Future)

**Use case:** Full-text search across multiple fields

**Example:** Using MongoDB text index

**Implementation:**
```typescript
if (sanitizedFilters.textSearch?.trim()) {
  searchFilter.$text = { $search: sanitizedFilters.textSearch.trim() };
}
```

## Security Best Practices

1. **Always sanitize filters** using `mongo-sanitize` to prevent NoSQL injection
2. **Validate ObjectIds** before using in queries
3. **Validate numeric values** before using in range queries
4. **Use parameterized queries** - never construct queries from user input directly

## Database Indexing

Ensure proper indexes exist for filtered fields:

```typescript
// In model schema
manufacturer: {
  type: String,
  index: true, // For efficient filtering
}

yearOfManufacture: {
  type: Number,
  index: true, // For range queries
}
```

## Filter Processing Utility

The `searchParamsToFilters` utility automatically:
- Converts `string | string[]` to `string[]`
- Excludes `page` parameter
- Filters out empty/undefined values
- Handles multiple filter values consistently

**Usage:**
```typescript
import { searchParamsToFilters } from "@/utils/common";

const filters = searchParamsToFilters(searchParams);
```

## Common Patterns

### Filter Interface Pattern

```typescript
export interface EntitySearchFilters {
  // String array filters (multiple selection)
  manufacturer?: string[];
  model?: string[];
  district?: string[];
  
  // ObjectId array filters
  categoryId?: string[];
  subCategoryId?: string[];
  
  // Numeric range filters (single values)
  yearFrom?: string;
  yearTo?: string;
  priceFrom?: string;
  priceTo?: string;
}
```

### Repository Method Pattern

```typescript
async getAll(
  searchFilters: EntitySearchFilters = {},
  currentPage: number = 1,
  pageSize: number = 10
): Promise<PaginatedResponse> {
  try {
    await connectDB();
    
    // Sanitize filters
    const sanitizedFilters: EntitySearchFilters = {
      manufacturer: sanitize(searchFilters.manufacturer),
      model: sanitize(searchFilters.model),
      yearFrom: sanitize(searchFilters.yearFrom),
      yearTo: sanitize(searchFilters.yearTo),
    };
    
    // Build query filter
    const searchFilter: FilterQuery<typeof Entity> = {};
    
    // Add filter conditions
    if (sanitizedFilters.manufacturer) {
      searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
    }
    
    if (sanitizedFilters.model) {
      searchFilter.model = { $in: sanitizedFilters.model };
    }
    
    // Range filters
    if (sanitizedFilters.yearFrom) {
      const yearFromNum = Number(sanitizedFilters.yearFrom);
      if (!Number.isNaN(yearFromNum)) {
        searchFilter.yearOfManufacture = { $gte: yearFromNum };
      }
    }
    
    if (sanitizedFilters.yearTo) {
      const yearToNum = Number(sanitizedFilters.yearTo);
      if (!Number.isNaN(yearToNum)) {
        searchFilter.yearOfManufacture = {
          ...searchFilter.yearOfManufacture,
          $lte: yearToNum,
        };
      }
    }
    
    // Calculate pagination
    const skip = (currentPage - 1) * pageSize;
    const totalCount = await Entity.countDocuments(searchFilter);
    const totalPages = Math.ceil(totalCount / pageSize);
    
    // Fetch results
    const results = await Entity.find(searchFilter)
      .populate("user")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(pageSize);
    
    // Serialize and return
    const serialized = JSON.parse(JSON.stringify(results));
    
    return {
      data: serialized,
      totalCount,
      currentPage,
      totalPages,
      hasNextPage: currentPage < totalPages,
      hasPreviousPage: currentPage > 1,
    };
  } catch (error) {
    console.error("Error fetching entities:", error);
    throw new Error("Failed to fetch entities");
  }
}
```

## UI Implementation

### Step 1: Create Filters Component Structure

1. **Create Filters.tsx (Server Component):**
   ```typescript
   import { FC } from "react";
   import { FiltersProvider } from "@/components/filters/FiltersContext";
   import FiltersClient from "./FiltersClient";

   const Filters: FC = () => {
     return (
       <FiltersProvider>
         <FiltersClient />
       </FiltersProvider>
     );
   };

   export default Filters;
   ```

2. **Create Filters.styles.ts (Empty initially):**
   ```typescript
   "use client";
   import styled from "styled-components";

   // Empty styles file - will be populated later
   ```

3. **Create FiltersClient.tsx (Client Component):**

### Step 2: FiltersClient Implementation Pattern

#### Required Imports

```typescript
"use client";
import { FC, useCallback, useMemo, useState } from "react";
import { enableMapSet, produce } from "immer";
import SearchMultiSelect from "@/components/filters/SearchMultiSelect/SearchMultiSelect";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { MultiValue } from "react-select";
import {
  AllSelectedFilterOptionsMap,
  Option,
} from "@/components/filters/SearchMultiSelect/types";
```

#### State Management

```typescript
const [allSelectedFilterOptions, setAllSelectedFilterOptions] =
  useState<AllSelectedFilterOptionsMap>(
    new Map([
      ["filterParam1", []],
      ["filterParam2", []],
    ])
  );
```

#### Filter Dependencies

```typescript
// Extract selected values for dependent filters
const selectedParentIds = allSelectedFilterOptions
  .get("parentFilter")!
  .map((option) => option.value);

// Dependent filter options based on parent selection
const dependentOptions = useMemo(
  () => getDependentOptionsByParentIds(selectedParentIds),
  [selectedParentIds]
);
```

#### Handler Functions

1. **handleSubmitAllFilters** - Updates URL with selected filters:
   ```typescript
   const handleSubmitAllFilters = () => {
     const _searchParams = new URLSearchParams(searchParams);
     _searchParams.set("page", "1");
     const params = allSelectedFilterOptions.keys();
     params.forEach((paramName) => {
       const options = allSelectedFilterOptions.get(paramName)!;
       if (options.length > 0) {
         _searchParams.delete(paramName);
         options.forEach((option) => {
           _searchParams.append(paramName, option.value);
         });
       } else {
         _searchParams.delete(paramName);
       }
     });
     router.replace(`${pathname}?${_searchParams.toString()}`);
   };
   ```

2. **handleSetAllSelectedFilterOptions** - Updates filter state:
   ```typescript
   const handleSetAllSelectedFilterOptions = useCallback(
     (paramName: string, options: MultiValue<Option>) => {
       setAllSelectedFilterOptions((prevOptionsMap) => {
         return produce(prevOptionsMap, (draft) => {
           draft.set(paramName, [...options]);
           // Clear dependent filter when parent is cleared
           if (paramName === "parentFilter" && options.length === 0) {
             draft.set("dependentFilter", []);
           }
         });
       });
     },
     []
   );
   ```

3. **handleClearFiltersAndClose** - Clears all filters:
   ```typescript
   const handleClearFiltersAndClose = () => {
     setAllSelectedFilterOptions(
       new Map([
         ["filterParam1", []],
         ["filterParam2", []],
       ])
     );
     router.push(pathname);
   };
   ```

#### SearchMultiSelect Components

```typescript
<SearchMultiSelect
  displayName="фильтр 1"
  placeholder="Выберите значение"
  paramName="filterParam1"
  options={parentOptions}
  maxSelectedOptions={3}
  selectedOptions={allSelectedFilterOptions.get("filterParam1")!}
  setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
/>

<SearchMultiSelect
  placeholder="Выберите зависимое значение"
  displayName="зависимый фильтр"
  paramName="dependentFilter"
  options={dependentOptions}
  isDisabled={selectedParentIds.length === 0}
  maxSelectedOptions={3}
  selectedOptions={allSelectedFilterOptions.get("dependentFilter")!}
  setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
/>
```

### Step 3: Integration with Page

1. **Import Filters component in page.tsx:**
   ```typescript
   import Filters from "./_components/Filters/Filters";
   ```

2. **Wrap Filters in Suspense:**
   ```typescript
   <Suspense fallback={<LoadingFilters />}>
     <VehicleFilters>
       <Filters />
     </VehicleFilters>
   </Suspense>
   ```

### Example: Car Filters Implementation

```typescript
"use client";
import { FC, useCallback, useMemo, useState } from "react";
import { enableMapSet, produce } from "immer";
import SearchMultiSelect from "@/components/filters/SearchMultiSelect/SearchMultiSelect";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import {
  mapVehicleManufacturersToSelectOptions,
  getVehicleModelsToSelectOptionsByManufacturerIds,
} from "@/lib/vehicles/cars/vehicleModels";
import { VehicleManufacturerId } from "@/lib/vehicles/cars/vehicleManufacturers/types/vehicleManufacturer.schema";
import { MultiValue } from "react-select";
import {
  AllSelectedFilterOptionsMap,
  Option,
} from "@/components/filters/SearchMultiSelect/types";

enableMapSet();

const FiltersClient: FC = () => {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();
  const [allSelectedFilterOptions, setAllSelectedFilterOptions] =
    useState<AllSelectedFilterOptionsMap>(
      new Map([
        ["manufacturer", []],
        ["model", []],
      ])
    );

  const selectedManufacturerIds = allSelectedFilterOptions
    .get("manufacturer")!
    .map((option) => option.value) as VehicleManufacturerId[];

  const manufacturerOptions = useMemo(
    () => mapVehicleManufacturersToSelectOptions(),
    []
  );

  const modelOptions = useMemo(
    () => getVehicleModelsToSelectOptionsByManufacturerIds(selectedManufacturerIds),
    [selectedManufacturerIds]
  );

  const handleSetAllSelectedFilterOptions = useCallback(
    (paramName: string, options: MultiValue<Option>) => {
      setAllSelectedFilterOptions((prevOptionsMap) => {
        return produce(prevOptionsMap, (draft) => {
          draft.set(paramName, [...options]);
          if (paramName === "manufacturer" && options.length === 0) {
            draft.set("model", []);
          }
        });
      });
    },
    []
  );

  // ... other handlers (handleSubmitAllFilters, handleClearFiltersAndClose)

  return (
    <div>
      <SearchMultiSelect
        displayName="производители"
        placeholder="Выберите производителя"
        paramName="manufacturer"
        options={manufacturerOptions}
        maxSelectedOptions={3}
        selectedOptions={allSelectedFilterOptions.get("manufacturer")!}
        setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
      />
      
      <SearchMultiSelect
        placeholder="Выберите модель"
        displayName="модели"
        paramName="model"
        options={modelOptions}
        isDisabled={selectedManufacturerIds.length === 0}
        maxSelectedOptions={3}
        selectedOptions={allSelectedFilterOptions.get("model")!}
        setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
      />
    </div>
  );
};
```

### Best Practices for FiltersClient

1. **Use immer for state updates** - `produce` function for immutable updates
2. **Use useMemo for computed options** - Prevents unnecessary recalculations
3. **Use useCallback for handlers** - Prevents unnecessary re-renders
4. **Initialize state with Map** - Consistent with SearchMultiSelect pattern
5. **Clear dependent filters** - When parent filter is cleared, clear dependent filters
6. **Disable dependent filters** - When parent is empty, disable dependent filters
7. **Use SearchMultiSelect** - Reusable component for all multi-select filters
8. **URL synchronization** - All filters update URL params for sharing/bookmarking
9. **Reset page to 1** - When filters change, reset to first page

### Mobile/Desktop UI (Future)

- Desktop: Inline filters with buttons
- Mobile: Modal with filters and action buttons
- Use FiltersContext for modal state management
- Follow pattern from `professional-service/_components/Filters/`

## Implementation Example: Car Filters

### Repository Filter Interface

```typescript
export interface CarSearchFilters {
  manufacturer?: string[];
  model?: string[];
  yearFrom?: string; // Single value for range filter
  yearTo?: string;   // Single value for range filter
}
```

### Repository getAll Method

```typescript
async getAll(
  searchFilters: CarSearchFilters = {},
  currentPage: number = 1,
  pageSize: number = 10
): Promise<PaginatedResponse> {
  try {
    await connectDB();

    // Sanitize all incoming filters
    const sanitizedFilters: CarSearchFilters = {
      manufacturer: sanitize(searchFilters.manufacturer),
      model: sanitize(searchFilters.model),
      yearFrom: sanitize(searchFilters.yearFrom),
      yearTo: sanitize(searchFilters.yearTo),
    };

    // Build search filter
    const searchFilter: FilterQuery<typeof Car> = {};

    // Add manufacturer filter
    if (sanitizedFilters.manufacturer) {
      searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
    }

    // Add model filter
    if (sanitizedFilters.model) {
      searchFilter.model = { $in: sanitizedFilters.model };
    }

    // Add year range filters
    if (sanitizedFilters.yearFrom) {
      const yearFromNum = Number(sanitizedFilters.yearFrom);
      if (!Number.isNaN(yearFromNum)) {
        searchFilter.yearOfManufacture = { $gte: yearFromNum };
      }
    }

    if (sanitizedFilters.yearTo) {
      const yearToNum = Number(sanitizedFilters.yearTo);
      if (!Number.isNaN(yearToNum)) {
        if (searchFilter.yearOfManufacture) {
          searchFilter.yearOfManufacture = {
            ...searchFilter.yearOfManufacture,
            $lte: yearToNum,
          };
        } else {
          searchFilter.yearOfManufacture = { $lte: yearToNum };
        }
      }
    }

    // ... rest of pagination and query logic
  } catch (error) {
    // ... error handling
  }
}
```

### Page Component Filter Processing

```typescript
import { CarSearchFilters } from "@/lib/vehicles/cars/repository/CarRepository";

const CarsPage: FC<CarsPageProps> = async (props) => {
  const searchParams = (await props.searchParams) || {};
  const currentPage = Number(searchParams?.page) || 1;

  // Extract array filters
  const arrayFilters = searchParamsToFilters(searchParams);

  // Build filters object with proper types
  const filters: CarSearchFilters = {
    manufacturer: arrayFilters.manufacturer,
    model: arrayFilters.model,
  };

  // Handle single value filters (yearFrom/yearTo)
  if (searchParams.yearFrom) {
    filters.yearFrom = Array.isArray(searchParams.yearFrom)
      ? searchParams.yearFrom[0]
      : searchParams.yearFrom;
  }

  if (searchParams.yearTo) {
    filters.yearTo = Array.isArray(searchParams.yearTo)
      ? searchParams.yearTo[0]
      : searchParams.yearTo;
  }

  return (
    <CarsPageContainer>
      <Suspense key={contentKey} fallback={<Loading />}>
        <CarsContent filters={filters} currentPage={currentPage} />
      </Suspense>
    </CarsPageContainer>
  );
};
```

## References

- Follow the pattern established in:
  - `lib/professionals/professional-service/repository/ProfessionalServiceRepository.ts`
  - `lib/vehicles/cars/repository/CarRepository.ts`
  - `app/(public)/vehicles/cars/page.tsx`
