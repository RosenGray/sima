---
description: Filter implementation guidelines for listing pages (business logic, database, UI)
globs:
alwaysApply: true
---

# Filter Implementation Guidelines

## Overview

This guide covers implementing filters for listing pages, including search params processing, repository filtering, database queries, and UI components. Filters should be implemented step by step: first backend/database logic, then UI components.

## Implementation Steps

### Step 1: Define Filter Types

1. **Create filter interface in repository file:**
   ```typescript
   export interface EntitySearchFilters {
     filterParam1?: string[];
     filterParam2?: string[];
     numericFilter?: string[]; // For range filters like yearFrom/yearTo
   }
   ```

2. **Add filter params to page searchParams interface:**
   ```typescript
   interface EntityPageProps {
     searchParams?: Promise<{
       filterParam1?: string | string[];
       filterParam2?: string | string[];
       numericFilter?: string; // For single value filters like yearFrom
       page?: string;
     }>;
   }
   ```

### Step 2: Process Search Params to Filters

1. **Extract filters from searchParams** (handled in page component):
   ```typescript
   const filters = searchParamsToFilters(searchParams);
   ```

2. **Use `searchParamsToFilters` utility** from `@/utils/common`:
   - Automatically converts `string | string[]` to `string[]`
   - Excludes `page` by default
   - Filters out empty/undefined values

### Step 3: Update Repository getAll Method

#### Method Signature

```typescript
async getAll(
  searchFilters: EntitySearchFilters = {},
  currentPage: number = 1,
  pageSize: number = 10
): Promise<PaginatedResponse>
```

#### Implementation Pattern

1. **Add filter interface and update method signature**

2. **Sanitize filters** (prevent NoSQL injection):
   ```typescript
   import sanitize from "mongo-sanitize";
   
   const sanitizedFilters: EntitySearchFilters = {
     filterParam1: sanitize(searchFilters.filterParam1),
     filterParam2: sanitize(searchFilters.filterParam2),
   };
   ```

3. **Build MongoDB query filter:**
   ```typescript
   const searchFilter: FilterQuery<typeof Entity> = {};
   ```

4. **Add filter conditions:**
   
   **For string array filters (multiple selection):**
   ```typescript
   if (sanitizedFilters.filterParam1) {
     searchFilter.filterParam1 = { $in: sanitizedFilters.filterParam1 };
   }
   ```
   
   **For ObjectId array filters (with validation):**
   ```typescript
   if (sanitizedFilters.categoryId) {
     const isValidObjectId = sanitizedFilters.categoryId.every((id) => 
       mongoose.Types.ObjectId.isValid(id)
     );
     if (isValidObjectId) {
       searchFilter.category = { $in: sanitizedFilters.categoryId };
     } else {
       // Invalid ObjectId - return empty results
       searchFilter._id = new mongoose.Types.ObjectId();
     }
   }
   ```
   
   **For numeric range filters (yearFrom/yearTo):**
   ```typescript
   // Handle yearFrom (single value, not array)
   if (sanitizedFilters.yearFrom) {
     const yearFromNum = Number(sanitizedFilters.yearFrom);
     if (!Number.isNaN(yearFromNum)) {
       searchFilter.yearOfManufacture = { $gte: yearFromNum };
     }
   }
   
   // Handle yearTo (single value, not array)
   if (sanitizedFilters.yearTo) {
     const yearToNum = Number(sanitizedFilters.yearTo);
     if (!Number.isNaN(yearToNum)) {
       // Combine with existing yearOfManufacture filter if exists
       searchFilter.yearOfManufacture = {
         ...searchFilter.yearOfManufacture,
         $lte: yearToNum,
       };
     }
   }
   ```
   
   **For enum filters:**
   ```typescript
   if (sanitizedFilters.district) {
     searchFilter.district = { $in: sanitizedFilters.district };
   }
   ```

5. **Use filter in query:**
   ```typescript
   const totalCount = await Entity.countDocuments(searchFilter);
   const results = await Entity.find(searchFilter)
     .populate("user")
     .sort({ createdAt: -1 })
     .skip(skip)
     .limit(pageSize);
   ```

### Step 4: Update Content Component

1. **Update filter interface to match repository:**
   ```typescript
   interface EntityContentProps {
     filters: EntitySearchFilters;
     currentPage: number;
   }
   ```

2. **Pass filters to repository:**
   ```typescript
   const entityResponse = await entityRepository.getAll(
     filters,
     currentPage,
     10
   );
   ```

### Step 5: Update Page Component

1. **Add filter params to searchParams interface**

2. **Import filter type from repository:**
   ```typescript
   import { EntitySearchFilters } from "@/lib/{category}/{entity}/repository/{Entity}Repository";
   ```

3. **Process filters using utility:**
   ```typescript
   // Extract array filters using utility
   const arrayFilters = searchParamsToFilters(searchParams);
   
   // Build filters object with proper types
   const filters: EntitySearchFilters = {
     manufacturer: arrayFilters.manufacturer,
     model: arrayFilters.model,
     // Add other array filters here
   };
   ```

4. **Handle special cases (single value filters like yearFrom/yearTo):**
   ```typescript
   // Handle yearFrom and yearTo as single values (not arrays) for range queries
   if (searchParams.yearFrom) {
     filters.yearFrom = Array.isArray(searchParams.yearFrom) 
       ? searchParams.yearFrom[0] 
       : searchParams.yearFrom;
   }
   
   if (searchParams.yearTo) {
     filters.yearTo = Array.isArray(searchParams.yearTo) 
       ? searchParams.yearTo[0] 
       : searchParams.yearTo;
   }
   ```

5. **Pass filters to content component:**
   ```typescript
   <EntityContent filters={filters} currentPage={currentPage} />
   ```

## Filter Types

### 1. String Array Filters (Multiple Selection)

**Use case:** Multiple values can be selected (e.g., manufacturer, model, district)

**Example:** `manufacturer: ["Toyota", "Honda", "BMW"]`

**Implementation:**
```typescript
// Interface
manufacturer?: string[];

// Query
if (sanitizedFilters.manufacturer) {
  searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
}
```

### 2. ObjectId Array Filters

**Use case:** Filtering by referenced entities (e.g., categoryId, subCategoryId)

**Example:** `categoryId: ["507f1f77bcf86cd799439011", "507f191e810c19729de860ea"]`

**Implementation:**
```typescript
// Interface
categoryId?: string[];

// Query with validation
if (sanitizedFilters.categoryId) {
  const isValidObjectId = sanitizedFilters.categoryId.every((id) => 
    mongoose.Types.ObjectId.isValid(id)
  );
  if (isValidObjectId) {
    searchFilter.category = { $in: sanitizedFilters.categoryId };
  } else {
    // Invalid ObjectId - return empty results
    searchFilter._id = new mongoose.Types.ObjectId();
  }
}
```

### 3. Numeric Range Filters (Single Value)

**Use case:** Range queries for numeric fields (e.g., yearFrom, yearTo, priceFrom, priceTo)

**Example:** `yearFrom: "2020"`, `yearTo: "2024"`

**Implementation:**
```typescript
// Interface - single string value, not array
yearFrom?: string;
yearTo?: string;

// Query - combine with $gte and $lte
if (sanitizedFilters.yearFrom) {
  const yearFromNum = Number(sanitizedFilters.yearFrom);
  if (!Number.isNaN(yearFromNum)) {
    searchFilter.yearOfManufacture = { $gte: yearFromNum };
  }
}

if (sanitizedFilters.yearTo) {
  const yearToNum = Number(sanitizedFilters.yearTo);
  if (!Number.isNaN(yearToNum)) {
    searchFilter.yearOfManufacture = {
      ...searchFilter.yearOfManufacture,
      $lte: yearToNum,
    };
  }
}
```

### 4. Enum Filters

**Use case:** Filtering by enum values (e.g., district, transmission, engineType)

**Example:** `district: ["Center", "North"]`

**Implementation:**
```typescript
// Interface
district?: string[];

// Query
if (sanitizedFilters.district) {
  searchFilter.district = { $in: sanitizedFilters.district };
}
```

### 5. Price Range Filters (Single Value with Comma Formatting)

**Use case:** Price range inputs with comma formatting (e.g., priceFrom, priceTo)

**Example:** `priceFrom: "10,000"`, `priceTo: "50,000"` (displayed with commas, stored as numbers)

**Implementation:**

**Schema (in `@/lib/common/types/common.types`):**
```typescript
export const PriceFromToSchema = z.object({
  priceFrom: z
    .string()
    .optional()
    .refine((val) => val == null || /^-?\d[\d,]*$/.test(val), {
      message: "Price must be a numeric string, optionally containing commas.",
    })
    .transform((val) => {
      if (val == null) return undefined;
      const cleaned = val.replace(/,/g, "");
      const num = Number(cleaned);
      return isNaN(num) ? undefined : num;
    }),
  priceTo: z
    .string()
    .optional()
    .refine((val) => val == null || /^-?\d[\d,]*$/.test(val), {
      message: "Price must be a numeric string, optionally containing commas.",
    })
    .transform((val) => {
      if (val == null) return undefined;
      const cleaned = val.replace(/,/g, "");
      const num = Number(cleaned);
      return isNaN(num) ? undefined : num;
    }),
});
```

**UI Component:**
```typescript
import PriceTextSearch from "@/components/filters/PriceTextSearch/PriceTextSearch";

<PriceTextSearch
  name="priceFrom"
  placeholder="0"
  defaultValue={searchParams.get("priceFrom") ?? undefined}
/>
```

**Repository Query:**
```typescript
// Interface - single string value, not array (but schema transforms to number)
priceFrom?: number; // After schema transformation
priceTo?: number;   // After schema transformation

// Query - values are already numbers after schema transformation
if (sanitizedFilters.priceFrom) {
  searchFilter.price = { $gte: sanitizedFilters.priceFrom };
}

if (sanitizedFilters.priceTo) {
  searchFilter.price = {
    ...searchFilter.price,
    $lte: sanitizedFilters.priceTo,
  };
}
```

**Note:** The schema transforms comma-formatted strings to numbers, so the repository receives numbers, not strings.

### 6. Text Input Filters (Single Value)

**Use case:** Text inputs for single values (e.g., color, text search)

**Example:** `color: "red"`

**Implementation:**
```typescript
// Interface - single string value, not array
color?: string;

// Query - use regex for text search
if (sanitizedFilters.color) {
  searchFilter.color = { $regex: sanitizedFilters.color, $options: "i" };
}
```

### 7. Text Search Filters (Future)

**Use case:** Full-text search across multiple fields

**Example:** Using MongoDB text index

**Implementation:**
```typescript
if (sanitizedFilters.textSearch?.trim()) {
  searchFilter.$text = { $search: sanitizedFilters.textSearch.trim() };
}
```

## Security Best Practices

1. **Always sanitize filters** using `mongo-sanitize` to prevent NoSQL injection
2. **Validate ObjectIds** before using in queries
3. **Validate numeric values** before using in range queries
4. **Use parameterized queries** - never construct queries from user input directly

## Database Indexing

Ensure proper indexes exist for filtered fields:

```typescript
// In model schema
manufacturer: {
  type: String,
  index: true, // For efficient filtering
}

yearOfManufacture: {
  type: Number,
  index: true, // For range queries
}
```

## Filter Processing Utility

The `searchParamsToFilters` utility automatically:
- Converts `string | string[]` to `string[]`
- Excludes `page` parameter
- Filters out empty/undefined values
- Handles multiple filter values consistently

**Usage:**
```typescript
import { searchParamsToFilters } from "@/utils/common";

const filters = searchParamsToFilters(searchParams);
```

## Common Patterns

### Filter Interface Pattern

```typescript
export interface EntitySearchFilters {
  // String array filters (multiple selection)
  manufacturer?: string[];
  model?: string[];
  district?: string[];
  
  // ObjectId array filters
  categoryId?: string[];
  subCategoryId?: string[];
  
  // Numeric range filters (single values)
  yearFrom?: string;
  yearTo?: string;
  priceFrom?: string;
  priceTo?: string;
  
  // Text input filters (single values)
  color?: string;
  textSearch?: string;
}
```

### Repository Method Pattern

```typescript
async getAll(
  searchFilters: EntitySearchFilters = {},
  currentPage: number = 1,
  pageSize: number = 10
): Promise<PaginatedResponse> {
  try {
    await connectDB();
    
    // Sanitize filters
    const sanitizedFilters: EntitySearchFilters = {
      manufacturer: sanitize(searchFilters.manufacturer),
      model: sanitize(searchFilters.model),
      yearFrom: sanitize(searchFilters.yearFrom),
      yearTo: sanitize(searchFilters.yearTo),
    };
    
    // Build query filter
    const searchFilter: FilterQuery<typeof Entity> = {};
    
    // Add filter conditions
    if (sanitizedFilters.manufacturer) {
      searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
    }
    
    if (sanitizedFilters.model) {
      searchFilter.model = { $in: sanitizedFilters.model };
    }
    
    // Range filters (numeric text inputs)
    if (sanitizedFilters.yearFrom) {
      const yearFromNum = Number(sanitizedFilters.yearFrom);
      if (!Number.isNaN(yearFromNum)) {
        searchFilter.yearOfManufacture = { $gte: yearFromNum };
      }
    }
    
    if (sanitizedFilters.yearTo) {
      const yearToNum = Number(sanitizedFilters.yearTo);
      if (!Number.isNaN(yearToNum)) {
        searchFilter.yearOfManufacture = {
          ...searchFilter.yearOfManufacture,
          $lte: yearToNum,
        };
      }
    }
    
    // Text input filters (numeric range)
    if (sanitizedFilters.priceFrom) {
      const priceFromNum = Number(sanitizedFilters.priceFrom);
      if (!Number.isNaN(priceFromNum)) {
        searchFilter.price = { $gte: priceFromNum };
      }
    }
    
    if (sanitizedFilters.priceTo) {
      const priceToNum = Number(sanitizedFilters.priceTo);
      if (!Number.isNaN(priceToNum)) {
        searchFilter.price = {
          ...searchFilter.price,
          $lte: priceToNum,
        };
      }
    }
    
    // Text input filters (string/text)
    if (sanitizedFilters.color) {
      searchFilter.color = { $regex: sanitizedFilters.color, $options: "i" };
    }
    
    // Calculate pagination
    const skip = (currentPage - 1) * pageSize;
    const totalCount = await Entity.countDocuments(searchFilter);
    const totalPages = Math.ceil(totalCount / pageSize);
    
    // Fetch results
    const results = await Entity.find(searchFilter)
      .populate("user")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(pageSize);
    
    // Serialize and return
    const serialized = JSON.parse(JSON.stringify(results));
    
    return {
      data: serialized,
      totalCount,
      currentPage,
      totalPages,
      hasNextPage: currentPage < totalPages,
      hasPreviousPage: currentPage > 1,
    };
  } catch (error) {
    console.error("Error fetching entities:", error);
    throw new Error("Failed to fetch entities");
  }
}
```

## UI Implementation

### Step 1: Create Filters Component Structure

1. **Create Filters.tsx (Server Component):**
   ```typescript
   import { FC } from "react";
   import { FiltersProvider } from "@/components/filters/FiltersContext";
   import FiltersClient from "./FiltersClient";

   const Filters: FC = () => {
     return (
       <FiltersProvider>
         <FiltersClient />
       </FiltersProvider>
     );
   };

   export default Filters;
   ```

2. **Create Filters.styles.ts (Empty initially):**
   ```typescript
   "use client";
   import styled from "styled-components";

   // Empty styles file - will be populated later
   ```

3. **Create filters.types.ts (For Text Input Validation):**
   ```typescript
   import { z } from "zod";
   import { PriceFromToSchema } from "@/lib/common/types/common.types";

   // Combine multiple schemas if needed
   export const EntityFilterSchema = z.object({
     ...PriceFromToSchema.shape, // Includes priceFrom and priceTo with comma formatting
     color: z.number().optional(), // or z.string().optional() for text
     // Add other text input fields here
   });

   export type EntityFilter = z.infer<typeof EntityFilterSchema>;
   ```
   
   **Note:** `PriceFromToSchema` handles:
   - Validation of comma-formatted numeric strings (regex: `/^-?\d[\d,]*$/`)
   - Transformation from formatted string to number (removes commas, converts to number)
   - Optional fields (both `priceFrom` and `priceTo` are optional)

4. **Create FiltersClient.tsx (Client Component):**

### Step 2: FiltersClient Implementation Pattern

#### Overview

FiltersClient supports three types of filters:

1. **Dropdown Filters (SearchMultiSelect)**: Multi-select dropdowns managed via `allSelectedFilterOptions` Map state
2. **Text Input Filters (TextSearch)**: Text inputs managed via form FormData with Zod validation
3. **Price Input Filters (PriceTextSearch)**: Price inputs with comma formatting, managed via form FormData with Zod validation

All types are combined in a single form and submitted together via `handleSubmitAllFilters`.

#### Required Imports

```typescript
"use client";
import { FC, useCallback, useMemo, useRef, useState } from "react";
import { enableMapSet, produce } from "immer";
import SearchMultiSelect from "@/components/filters/SearchMultiSelect/SearchMultiSelect";
import TextSearch from "@/components/filters/TextSearch/TextSearch";
import PriceTextSearch from "@/components/filters/PriceTextSearch/PriceTextSearch";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { parseWithZod } from "@conform-to/zod";
import { MultiValue } from "react-select";
import {
  AllSelectedFilterOptionsMap,
  Option,
} from "@/components/filters/SearchMultiSelect/types";
import { EntityFilter, EntityFilterSchema } from "./filters.types";
```

#### State Management

```typescript
const [allSelectedFilterOptions, setAllSelectedFilterOptions] =
  useState<AllSelectedFilterOptionsMap>(
    new Map([
      ["filterParam1", []],
      ["filterParam2", []],
    ])
  );
```

#### Filter Dependencies

```typescript
// Extract selected values for dependent filters
const selectedParentIds = allSelectedFilterOptions
  .get("parentFilter")!
  .map((option) => option.value);

// Dependent filter options based on parent selection
const dependentOptions = useMemo(
  () => getDependentOptionsByParentIds(selectedParentIds),
  [selectedParentIds]
);
```

#### Form Reference (For Text Inputs)

When using text input filters, add a form reference:

```typescript
const formRef = useRef<HTMLFormElement>(null);
```

#### Handler Functions

1. **handleSubmitAllFilters** - Updates URL with selected filters (both dropdowns and text inputs):
   ```typescript
   const handleSubmitAllFilters = () => {
     // Extract FormData for text inputs (if using form)
     const formData = new FormData(formRef.current!);
     const schemaKeys = Object.keys(FilterSchema.shape);
     const parseResult = parseWithZod(formData, { schema: FilterSchema });

     const _searchParams = new URLSearchParams(searchParams);
     _searchParams.set("page", "1");
     
     // Handle dropdown filters (SearchMultiSelect)
     const params = allSelectedFilterOptions.keys();
     params.forEach((paramName) => {
       const options = allSelectedFilterOptions.get(paramName)!;
       if (options.length > 0) {
         _searchParams.delete(paramName);
         options.forEach((option) => {
           _searchParams.append(paramName, option.value);
         });
       } else {
         _searchParams.delete(paramName);
       }
     });

     // Handle text input filters (TextSearch)
     if (parseResult.status === "success") {
       const values = parseResult.value;
       schemaKeys.forEach((key) => {
         _searchParams.delete(key);
         const value = values[key as keyof FilterType];
         const valueString = value?.toString();
         if (valueString && valueString !== "") {
           _searchParams.append(key, valueString);
         }
       });
     } else if (parseResult.status === "error" && parseResult.error) {
       // Graceful degradation: add non-error fields to URL
       const { error } = parseResult;
       for (let i = 0; i < schemaKeys.length; i++) {
         const key = schemaKeys[i];
         _searchParams.delete(key);
         const errors = error[key];
         if (errors && errors.length > 0) continue; // Skip fields with errors
         const value = formData.get(key);
         const valueString = value?.toString();
         if (valueString && valueString !== "") {
           _searchParams.append(key, valueString);
         }
       }
     }

     router.replace(`${pathname}?${_searchParams.toString()}`);
   };
   ```

2. **handleSetAllSelectedFilterOptions** - Updates filter state:
   ```typescript
   const handleSetAllSelectedFilterOptions = useCallback(
     (paramName: string, options: MultiValue<Option>) => {
       setAllSelectedFilterOptions((prevOptionsMap) => {
         return produce(prevOptionsMap, (draft) => {
           draft.set(paramName, [...options]);
           // Clear dependent filter when parent is cleared
           if (paramName === "parentFilter" && options.length === 0) {
             draft.set("dependentFilter", []);
           }
         });
       });
     },
     []
   );
   ```

3. **handleClearFiltersAndClose** - Clears all filters:
   ```typescript
   const handleClearFiltersAndClose = () => {
     setAllSelectedFilterOptions(
       new Map([
         ["filterParam1", []],
         ["filterParam2", []],
       ])
     );
     router.push(pathname);
   };
   ```

#### Form Wrapper (For Text Inputs)

When using text input filters, wrap all filters in a form:

```typescript
<form
  ref={formRef}
  onSubmit={(e) => e.preventDefault()}
  style={{
    display: "flex",
    gap: "12px",
    flexWrap: "wrap",
    alignItems: "center",
  }}
>
  {/* Dropdown and text filters go here */}
</form>
```

#### SearchMultiSelect Components

```typescript
<SearchMultiSelect
  displayName="фильтр 1"
  placeholder="Выберите значение"
  paramName="filterParam1"
  options={parentOptions}
  maxSelectedOptions={3}
  selectedOptions={allSelectedFilterOptions.get("filterParam1")!}
  setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
/>

<SearchMultiSelect
  placeholder="Выберите зависимое значение"
  displayName="зависимый фильтр"
  paramName="dependentFilter"
  options={dependentOptions}
  isDisabled={selectedParentIds.length === 0}
  maxSelectedOptions={3}
  selectedOptions={allSelectedFilterOptions.get("dependentFilter")!}
  setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
/>
```

#### TextSearch Components

```typescript
import TextSearch from "@/components/filters/TextSearch/TextSearch";

<TextSearch
  name="color"
  placeholder="Цвет"
  type="text"
  defaultValue={searchParams.get("color")?.toString()}
/>
```

#### PriceTextSearch Components

For price range filters, use `PriceTextSearch` which automatically formats numbers with commas:

```typescript
import PriceTextSearch from "@/components/filters/PriceTextSearch/PriceTextSearch";

<PriceTextSearch
  name="priceFrom"
  placeholder="0"
  defaultValue={searchParams.get("priceFrom") ?? undefined}
/>

<PriceTextSearch
  name="priceTo"
  placeholder="0"
  defaultValue={searchParams.get("priceTo") ?? undefined}
/>
```

**Note:** `PriceTextSearch`:
- Automatically formats numbers with commas (e.g., "1,000,000") using `formatNumberWithCommas` utility from `@/utils/common`
- Uses `type="text"` with `pattern="[\d,]*"` and `inputMode="numeric"`
- Displays currency symbol (₪)
- Manages internal state for formatted display value
- Works with `PriceFromToSchema` from `@/lib/common/types/common.types` which validates and transforms comma-formatted strings to numbers

### Step 3: Integration with Page

1. **Import Filters component in page.tsx:**
   ```typescript
   import Filters from "./_components/Filters/Filters";
   ```

2. **Wrap Filters in Suspense:**
   ```typescript
   <Suspense fallback={<LoadingFilters />}>
     <VehicleFilters>
       <Filters />
     </VehicleFilters>
   </Suspense>
   ```

### Step 4: Create Filter Schema (For Text Inputs)

When using text input filters, create a Zod schema for validation:

1. **Create `filters.types.ts` in filters directory:**
   ```typescript
   import { z } from "zod";
   import { PriceFromToSchema } from "@/lib/common/types/common.types";

   // Combine multiple schemas if needed
   export const EntityFilterSchema = z.object({
     ...PriceFromToSchema.shape,
     color: z.number().optional(), // or z.string().optional() for text
     // Add other text input fields here
   });

   export type EntityFilter = z.infer<typeof EntityFilterSchema>;
   ```

2. **Import in FiltersClient:**
   ```typescript
   import { parseWithZod } from "@conform-to/zod";
   import { EntityFilter, EntityFilterSchema } from "./filters.types";
   ```

### Example: Car Filters Implementation (With Dropdowns and Text Inputs)

```typescript
"use client";
import {
  FC,
  useCallback,
  useMemo,
  useRef,
  useState,
} from "react";
import { enableMapSet, produce } from "immer";
import SearchMultiSelect from "@/components/filters/SearchMultiSelect/SearchMultiSelect";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import {
  mapVehicleManufacturersToSelectOptions,
  getVehicleModelsToSelectOptionsByManufacturerIds,
} from "@/lib/vehicles/cars/vehicleModels";
import { VehicleManufacturerId } from "@/lib/vehicles/cars/vehicleManufacturers/types/vehicleManufacturer.schema";
import { MultiValue } from "react-select";
import {
  AllSelectedFilterOptionsMap,
  Option,
} from "@/components/filters/SearchMultiSelect/types";
import { Button } from "@radix-ui/themes";
import { parseWithZod } from "@conform-to/zod";
import TextSearch from "@/components/filters/TextSearch/TextSearch";
import PriceTextSearch from "@/components/filters/PriceTextSearch/PriceTextSearch";
import { CarFilter, CarFilterSchema } from "./filters.types";

enableMapSet();

const FiltersClient: FC = () => {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();
  const formRef = useRef<HTMLFormElement>(null);
  const [allSelectedFilterOptions, setAllSelectedFilterOptions] =
    useState<AllSelectedFilterOptionsMap>(
      new Map([
        ["manufacturer", []],
        ["model", []],
      ])
    );

  const selectedManufacturerIds = allSelectedFilterOptions
    .get("manufacturer")!
    .map((option) => option.value) as VehicleManufacturerId[];

  const manufacturerOptions = useMemo(
    () => mapVehicleManufacturersToSelectOptions(),
    []
  );

  const modelOptions = useMemo(
    () => getVehicleModelsToSelectOptionsByManufacturerIds(selectedManufacturerIds),
    [selectedManufacturerIds]
  );

  const handleSubmitAllFilters = () => {
    const formData = new FormData(formRef.current!);
    const schemaKeys = Object.keys(CarFilterSchema.shape);
    const parseResult = parseWithZod(formData, { schema: CarFilterSchema });

    const _searchParams = new URLSearchParams(searchParams);
    _searchParams.set("page", "1");
    
    // Handle dropdown filters
    const params = allSelectedFilterOptions.keys();
    params.forEach((paramName) => {
      const options = allSelectedFilterOptions.get(paramName)!;
      if (options.length > 0) {
        _searchParams.delete(paramName);
        options.forEach((option) => {
          _searchParams.append(paramName, option.value);
        });
      } else {
        _searchParams.delete(paramName);
      }
    });

    // Handle text input filters
    if (parseResult.status === "success") {
      const values = parseResult.value;
      schemaKeys.forEach((key) => {
        _searchParams.delete(key);
        const value = values[key as keyof CarFilter];
        const valueString = value?.toString();
        if (valueString && valueString !== "") {
          _searchParams.append(key, valueString);
        }
      });
    } else if (parseResult.status === "error" && parseResult.error) {
      const { error } = parseResult;
      for (let i = 0; i < schemaKeys.length; i++) {
        const key = schemaKeys[i];
        _searchParams.delete(key);
        const errors = error[key];
        if (errors && errors.length > 0) continue;
        const value = formData.get(key);
        const valueString = value?.toString();
        if (valueString && valueString !== "") {
          _searchParams.append(key, valueString);
        }
      }
    }

    router.replace(`${pathname}?${_searchParams.toString()}`);
  };

  const handleSetAllSelectedFilterOptions = useCallback(
    (paramName: string, options: MultiValue<Option>) => {
      setAllSelectedFilterOptions((prevOptionsMap) => {
        return produce(prevOptionsMap, (draft) => {
          draft.set(paramName, [...options]);
          if (paramName === "manufacturer" && options.length === 0) {
            draft.set("model", []);
          }
        });
      });
    },
    []
  );

  const handleClearFiltersAndClose = () => {
    setAllSelectedFilterOptions(
      new Map([
        ["manufacturer", []],
        ["model", []],
      ])
    );
    router.push(pathname);
  };

  return (
    <div>
      <form
        ref={formRef}
        onSubmit={(e) => e.preventDefault()}
        style={{
          display: "flex",
          gap: "12px",
          flexWrap: "wrap",
          alignItems: "center",
        }}
      >
        {/* Dropdown filters */}
        <SearchMultiSelect
          displayName="производители"
          placeholder="Выберите производителя"
          paramName="manufacturer"
          options={manufacturerOptions}
          maxSelectedOptions={3}
          selectedOptions={allSelectedFilterOptions.get("manufacturer")!}
          setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
        />
        
        <SearchMultiSelect
          placeholder="Выберите модель"
          displayName="модели"
          paramName="model"
          options={modelOptions}
          isDisabled={selectedManufacturerIds.length === 0}
          maxSelectedOptions={3}
          selectedOptions={allSelectedFilterOptions.get("model")!}
          setAllSelectedFilterOptions={handleSetAllSelectedFilterOptions}
        />

        {/* Price input filters */}
        <PriceTextSearch
          name="priceFrom"
          placeholder="0"
          defaultValue={searchParams.get("priceFrom") ?? undefined}
        />
        <PriceTextSearch
          name="priceTo"
          placeholder="0"
          defaultValue={searchParams.get("priceTo") ?? undefined}
        />
        
        {/* Text input filters */}
        <TextSearch
          name="color"
          placeholder="Цвет"
          type="text"
          defaultValue={searchParams.get("color")?.toString()}
        />

        {/* Action buttons */}
        <Button
          variant="outline"
          color="gray"
          onClick={handleSubmitAllFilters}
          size="3"
        >
          Поиск
        </Button>
        <Button
          variant="outline"
          color="gray"
          disabled={searchParams.size === 0}
          onClick={handleClearFiltersAndClose}
          size="3"
        >
          Очистить все фильтры
        </Button>
      </form>
    </div>
  );
};
```

### Best Practices for FiltersClient

1. **Use immer for state updates** - `produce` function for immutable updates
2. **Use useMemo for computed options** - Prevents unnecessary recalculations
3. **Use useCallback for handlers** - Prevents unnecessary re-renders
4. **Initialize state with Map** - Consistent with SearchMultiSelect pattern
5. **Clear dependent filters** - When parent filter is cleared, clear dependent filters
6. **Disable dependent filters** - When parent is empty, disable dependent filters
7. **Use SearchMultiSelect** - Reusable component for all multi-select filters
8. **Use TextSearch** - Reusable component for regular text input filters
9. **Use PriceTextSearch** - Reusable component for price input filters with comma formatting
10. **Wrap in form** - When using text inputs, wrap all filters in a `<form>` with `formRef`
10. **Validate with Zod** - Use `parseWithZod` with a schema for text input validation
11. **Graceful error handling** - On validation errors, still add non-error fields to URL
12. **Default values from URL** - Initialize text inputs with values from `searchParams.get()`
13. **URL synchronization** - All filters update URL params for sharing/bookmarking
14. **Reset page to 1** - When filters change, reset to first page

### Mobile/Desktop UI (Future)

- Desktop: Inline filters with buttons
- Mobile: Modal with filters and action buttons
- Use FiltersContext for modal state management
- Follow pattern from `professional-service/_components/Filters/`

## Implementation Example: Car Filters

### Repository Filter Interface

```typescript
export interface CarSearchFilters {
  manufacturer?: string[];
  model?: string[];
  yearFrom?: string; // Single value for range filter
  yearTo?: string;   // Single value for range filter
}
```

### Repository getAll Method

```typescript
async getAll(
  searchFilters: CarSearchFilters = {},
  currentPage: number = 1,
  pageSize: number = 10
): Promise<PaginatedResponse> {
  try {
    await connectDB();

    // Sanitize all incoming filters
    const sanitizedFilters: CarSearchFilters = {
      manufacturer: sanitize(searchFilters.manufacturer),
      model: sanitize(searchFilters.model),
      yearFrom: sanitize(searchFilters.yearFrom),
      yearTo: sanitize(searchFilters.yearTo),
    };

    // Build search filter
    const searchFilter: FilterQuery<typeof Car> = {};

    // Add manufacturer filter
    if (sanitizedFilters.manufacturer) {
      searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
    }

    // Add model filter
    if (sanitizedFilters.model) {
      searchFilter.model = { $in: sanitizedFilters.model };
    }

    // Add year range filters
    if (sanitizedFilters.yearFrom) {
      const yearFromNum = Number(sanitizedFilters.yearFrom);
      if (!Number.isNaN(yearFromNum)) {
        searchFilter.yearOfManufacture = { $gte: yearFromNum };
      }
    }

    if (sanitizedFilters.yearTo) {
      const yearToNum = Number(sanitizedFilters.yearTo);
      if (!Number.isNaN(yearToNum)) {
        if (searchFilter.yearOfManufacture) {
          searchFilter.yearOfManufacture = {
            ...searchFilter.yearOfManufacture,
            $lte: yearToNum,
          };
        } else {
          searchFilter.yearOfManufacture = { $lte: yearToNum };
        }
      }
    }

    // ... rest of pagination and query logic
  } catch (error) {
    // ... error handling
  }
}
```

### Page Component Filter Processing

```typescript
import { CarSearchFilters } from "@/lib/vehicles/cars/repository/CarRepository";

const CarsPage: FC<CarsPageProps> = async (props) => {
  const searchParams = (await props.searchParams) || {};
  const currentPage = Number(searchParams?.page) || 1;

  // Extract array filters
  const arrayFilters = searchParamsToFilters(searchParams);

  // Build filters object with proper types
  const filters: CarSearchFilters = {
    manufacturer: arrayFilters.manufacturer,
    model: arrayFilters.model,
  };

  // Handle single value filters (yearFrom/yearTo)
  if (searchParams.yearFrom) {
    filters.yearFrom = Array.isArray(searchParams.yearFrom)
      ? searchParams.yearFrom[0]
      : searchParams.yearFrom;
  }

  if (searchParams.yearTo) {
    filters.yearTo = Array.isArray(searchParams.yearTo)
      ? searchParams.yearTo[0]
      : searchParams.yearTo;
  }

  return (
    <CarsPageContainer>
      <Suspense key={contentKey} fallback={<Loading />}>
        <CarsContent filters={filters} currentPage={currentPage} />
      </Suspense>
    </CarsPageContainer>
  );
};
```

## References

- Follow the pattern established in:
  - `lib/professionals/professional-service/repository/ProfessionalServiceRepository.ts`
  - `lib/vehicles/cars/repository/CarRepository.ts`
  - `app/(public)/vehicles/cars/page.tsx`
