# Vehicle Advertisement End-to-End Implementation Guide

## Overview

This document provides a comprehensive guide for implementing vehicle advertisement functionality across all vehicle categories. It documents the complete flow from publishing an ad to viewing, filtering, and editing, with reusable patterns for all 8 vehicle categories.

## Architecture Diagram

```mermaid
flowchart TB
    subgraph PublishFlow [Publishing Flow]
        PF1[User visits /publish-ad/vehicles]
        PF2[Selects category]
        PF3[/publish-ad/vehicles/category/create]
        PF4[EntityPublishForm]
        PF5[publishEntityAd action]
        PF6[uploadFiles + repository.create]
        PF7[Redirect to /vehicles/category]
    end
    
    subgraph ViewFlow [Viewing Flow]
        VF1[User visits /vehicles/category]
        VF2[Page extracts filters from searchParams]
        VF3[repository.getAll with filters]
        VF4[Content renders cards]
        VF5[User clicks card]
        VF6[/vehicles/category/publicId]
        VF7[DetailClient shows full details]
    end
    
    subgraph EditFlow [Edit Flow]
        EF1[Owner clicks Edit on detail page]
        EF2[/publish-ad/vehicles/category/edit/publicId]
        EF3[EntityPublishForm with existing data]
        EF4[editEntityAd action]
        EF5[Handle image changes + repository.edit]
        EF6[Redirect to /vehicles/category]
    end
    
    subgraph DataLayer [Data Layer]
        DL1[Entity Model - Mongoose]
        DL2[EntityRepository - CRUD + filters]
        DL3[entity.schema.ts - Zod validation]
        DL4[Static Data - manufacturers/models]
    end
    
    PF1 --> PF2 --> PF3 --> PF4 --> PF5 --> PF6 --> PF7
    VF1 --> VF2 --> VF3 --> VF4 --> VF5 --> VF6 --> VF7
    VF7 --> EF1 --> EF2 --> EF3 --> EF4 --> EF5 --> EF6
    
    PF5 --> DL1
    VF3 --> DL2
    PF4 --> DL3
    PF4 --> DL4
```

## Vehicle Categories

| Category ID | Entity Name | Has Manufacturer/Model | Unique Fields | Complexity |
|-------------|-------------|------------------------|---------------|------------|
| `cars` | Car | Yes (existing) | transmission, engineType, engineCapacity, numberOfHand, mileage, numberOfDoors, color, accessories | Complex |
| `off-road` | OffRoad | Yes (unique manufacturers) | driveType (4x4/AWD), groundClearance, offRoadFeatures | Complex |
| `commercial-vehicles` | CommercialVehicle | Yes (commercial vehicle manufacturers) | transmission, numberOfHand, mileage, numberOfDoors, color | Complex |
| `motorcycles` | Motorcycle | Yes (motorcycle manufacturers) | engineDisplacement, motorcycleCategory, hasABS | Complex |
| `scooters` | Scooter | Yes (simpler manufacturers) | engineDisplacement, powerType (electric/gas) | Medium |
| `atv` | Atv | Yes (ATV manufacturers) | engineDisplacement, terrainType, seating | Medium |
| `trailers` | Trailer | No | trailerType, capacity, axles, brakeType | Simple |
| `accessories` | Accessory | No | title, accessoryCategory, subcategory, condition | Simple |

---

## Complete File Structure Template

For each new vehicle category, create the following file structure:

### Data Layer (`lib/vehicles/{category}/`)

```
lib/vehicles/{category}/
├── actions/
│   ├── index.ts                          # Export all actions
│   ├── publish{Entity}Ad.ts              # Server action for creating ads
│   ├── edit{Entity}Ad.ts                 # Server action for editing ads
│   └── delete{Entity}Ad.ts               # Server action for deleting ads
├── models/
│   └── {Entity}.ts                       # Mongoose model definition
├── repository/
│   └── {Entity}Repository.ts             # Repository with CRUD + filtering
├── types/
│   ├── {entity}.schema.ts                # Zod validation schema
│   └── {entity}.types.ts                 # TypeScript types + enums
├── {category}Manufacturers/              # Only if category has manufacturer/model
│   ├── data.ts                           # Static manufacturer/model data
│   ├── index.ts                          # Export utility functions
│   └── types/
│       └── {entity}Manufacturer.schema.ts
└── {category}Models/                     # Only if category has manufacturer/model
    └── index.ts                          # Model selection utilities
```

### Public Pages (`app/(public)/vehicles/{category}/`)

```
app/(public)/vehicles/{category}/
├── page.tsx                              # Listing page (Server Component)
├── page.styles.ts                        # Page styled components
├── loading.tsx                           # Loading skeleton
├── loading.styles.ts                     # Loading styled components
├── [id]/
│   └── page.tsx                          # Detail page (Server Component)
└── _components/
    ├── {Entity}Content/
    │   └── {Entity}Content.tsx           # Content with data fetching
    ├── {Entity}Cards/
    │   ├── {Entity}Card.tsx              # Individual card component
    │   ├── {Entity}Card.styles.ts        # Card styled components
    │   └── {Entity}Cards.tsx             # Cards list wrapper
    ├── {Entity}DetailClient/
    │   ├── {Entity}DetailClient.tsx      # Detail client component
    │   └── {Entity}DetailClient.styles.ts
    ├── Filters/
    │   ├── Filters.tsx                   # Filters wrapper
    │   ├── FiltersClient.tsx             # Filters logic (Client Component)
    │   ├── Filters.styles.ts             # Filter styled components
    │   ├── Filters.utils.ts              # Filter helper functions
    │   └── filters.types.ts              # Filter Zod schema
    └── modals/
        └── MoreFiltersModal/
            ├── MoreFiltersModal.tsx
            └── MoreFiltersModal.styles.ts
```

### Private Pages (`app/(private)/publish-ad/vehicles/{category}/`)

```
app/(private)/publish-ad/vehicles/{category}/
└── [formMode]/
    ├── page.tsx                          # Create page (formMode === 'create')
    ├── page.styles.ts                    # Page styled components
    └── [id]/
        └── page.tsx                      # Edit page (formMode === 'edit')
```

### Form Component (`app/(private)/publish-ad/_components/vehicles/`)

```
app/(private)/publish-ad/_components/vehicles/
└── {Entity}PublishForm/
    ├── {Entity}PublishForm.tsx           # Form component (create + edit)
    └── {Entity}PublishForm.styles.ts     # Form styled components
```

---

## Base Schema Pattern

All vehicle categories share these common fields. Create a base interface or extend from common types.

### Common Fields (Required for All Categories)

```typescript
// Common interface for all vehicle ads
interface IBaseVehicleAd {
  // Identification
  id: string;
  publicId: string;                       // nanoid(10) - public-facing ID
  user: mongoose.Types.ObjectId;          // Reference to User model
  
  // Pricing
  price: number;                          // Required, stored as number
  
  // Description
  description: string;                    // Required
  
  // Location
  district: string;                       // Required - enum Districts
  city: string;                           // Required - city ID
  
  // Contact Information
  contactName: string;                    // Required
  contactPrimaryPhone: string;            // Required - digits only
  contactSecondaryPhone?: string;         // Optional
  contactEmail: string;                   // Required - valid email
  
  // Terms
  acceptTerms: boolean;                   // Required - must be true
  
  // Media
  images: FileUploadItem[];               // Required - at least 1 image
  
  // Timestamps (auto-generated by Mongoose)
  createdAt?: Date;
  updatedAt?: Date;
}
```

### Common Zod Schema Fields

```typescript
// Base schema fields to include in every category schema
const baseVehicleSchemaFields = {
  price: z
    .string({ required_error: "Введите цену" })
    .refine((val) => /^-?\d[\d,]*$/.test(val), {
      message: "Цена должна быть числом, содержащим запятые.",
    })
    .transform((val) => {
      const cleaned = val.replace(/,/g, "");
      return Number(cleaned);
    }),
  
  description: z.string({ required_error: "Введите описание" }),
  
  district: z.nativeEnum(Districts, { required_error: "Выберите район" }),
  
  city: z.string({ required_error: "Выберите город" }),
  
  contactName: z.string({ required_error: "Введите имя контакта" }),
  
  contactPrimaryPhone: z
    .string({ required_error: "Введите основной телефон" })
    .regex(/^[0-9]+$/, "Телефон может содержать только цифры"),
  
  contactSecondaryPhone: z
    .string()
    .regex(/^[0-9]+$/, "Телефон может содержать только цифры")
    .optional(),
  
  contactEmail: z
    .string({ required_error: "Электронная почта обязательна" })
    .email("Введите корректный адрес электронной почты"),
  
  acceptTerms: z
    .string({ required_error: "Вы должны согласиться с условиями" })
    .optional()
    .superRefine((value, ctx) => {
      if (value === "on") return true;
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Вы должны согласиться с условиями",
        fatal: true,
      });
      return z.NEVER;
    }),
  
  images: z
    .array(z.instanceof(File))
    .min(1, "Загрузите хотя бы 1 изображение")
    .superRefine((files, ctx) => {
      // File validation logic - see car.schema.ts for full implementation
    }),
};
```

### Common Mongoose Schema Fields

```typescript
// Common Mongoose schema fields
const baseVehicleSchemaDefinition = {
  publicId: {
    type: String,
    required: true,
    unique: true,
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
    index: true,
  },
  price: {
    type: Number,
    required: true,
    min: 0,
    index: true,
  },
  description: {
    type: String,
    required: true,
  },
  district: {
    type: String,
    required: true,
    index: true,
  },
  city: {
    type: String,
    required: true,
    index: true,
  },
  contactName: {
    type: String,
    required: true,
  },
  contactPrimaryPhone: {
    type: String,
    required: true,
  },
  contactSecondaryPhone: {
    type: String,
    required: false,
  },
  contactEmail: {
    type: String,
    required: true,
    lowercase: true,
    trim: true,
  },
  acceptTerms: {
    type: Boolean,
    required: true,
  },
  images: {
    type: [imageSchema],
    required: true,
  },
};

// Image schema (reuse across all categories)
const imageSchema = new mongoose.Schema(
  {
    originalName: { type: String, required: true },
    uniqueName: { type: String, required: true },
    url: { type: String, required: true },
    fieldname: { type: String, required: true },
    versionId: { type: String, required: false },
    folderName: { type: String, required: true },
  },
  {
    toJSON: {
      transform: (_doc, ret) => {
        ret.id = ret._id;
        delete ret._id;
      },
    },
  }
);
```

---

## Example Schema: Motorcycles (Complex Category)

Motorcycles have manufacturer/model relationships and unique technical specifications.

### Types (`lib/vehicles/motorcycles/types/motorcycle.types.ts`)

```typescript
import { IBaseVehicleAd } from "@/lib/vehicles/common/types";
import { SerializedUser } from "@/lib/auth/types/auth.schema";

// Motorcycle-specific enums
export enum MotorcycleCategory {
  SPORT = "sport",
  CRUISER = "cruiser",
  TOURING = "touring",
  NAKED = "naked",
  ADVENTURE = "adventure",
  ENDURO = "enduro",
  MOTOCROSS = "motocross",
  SCOOTER_MAXI = "scooterMaxi",
  CLASSIC = "classic",
  CAFE_RACER = "cafeRacer",
}

export enum MotorcycleEngineType {
  TWO_STROKE = "twoStroke",
  FOUR_STROKE = "fourStroke",
  ELECTRIC = "electric",
}

// Motorcycle interface extending base
export interface IMotorcycle extends IBaseVehicleAd {
  manufacturer: string;
  model: string;
  yearOfManufacture: number;
  engineDisplacement: number;           // in cc (cubic centimeters)
  engineType: MotorcycleEngineType;
  motorcycleCategory: MotorcycleCategory;
  mileage?: number;
  color?: string;
  hasABS: boolean;
  hasTractionControl?: boolean;
  numberOfCylinders?: number;
  accessories?: string;
}

// Serialized type for client-side use
export interface SerializedMotorcycle
  extends Omit<IMotorcycle, "createdAt" | "updatedAt" | "user"> {
  updatedAt: string;
  createdAt: string;
  user: SerializedUser;
}
```

### Zod Schema (`lib/vehicles/motorcycles/types/motorcycle.schema.ts`)

```typescript
import { z } from "zod";
import { Districts } from "@/lib/cities/types/cities.schema";
import { MotorcycleCategory, MotorcycleEngineType } from "./motorcycle.types";

export const SIZE_IN_MB = 5;
export const MAX_FILE_SIZE = SIZE_IN_MB * 1024 * 1024;
export const MAX_FILES = 5;

export const ACCEPTED_FILE_TYPES = [
  "image/png",
  "image/jpeg",
  "image/jpg",
  "image/webp",
];

export const createMotorcycleSchema = ({ minNumberOfImages = 1 }) => {
  return z.object({
    // Motorcycle-specific fields
    manufacturer: z.string({ required_error: "Выберите производителя" }),
    model: z.string({ required_error: "Выберите модель" }),
    yearOfManufacture: z.coerce
      .number({ required_error: "Введите год выпуска" })
      .min(1900, "Год должен быть не менее 1900"),
    engineDisplacement: z.coerce
      .number({ required_error: "Введите объем двигателя" })
      .min(1, "Объем двигателя должен быть не менее 1 куб.см"),
    engineType: z.nativeEnum(MotorcycleEngineType, {
      required_error: "Выберите тип двигателя",
    }),
    motorcycleCategory: z.nativeEnum(MotorcycleCategory, {
      required_error: "Выберите категорию мотоцикла",
    }),
    mileage: z.coerce
      .number()
      .min(0, "Пробег не может быть отрицательным")
      .optional(),
    color: z.string().optional(),
    hasABS: z
      .string()
      .optional()
      .transform((val) => val === "on"),
    hasTractionControl: z
      .string()
      .optional()
      .transform((val) => val === "on"),
    numberOfCylinders: z.coerce.number().optional(),
    accessories: z.string().optional(),
    
    // Base fields (price, location, contact, etc.)
    price: z
      .string({ required_error: "Введите цену" })
      .refine((val) => /^-?\d[\d,]*$/.test(val), {
        message: "Цена должна быть числом.",
      })
      .transform((val) => Number(val.replace(/,/g, ""))),
    description: z.string({ required_error: "Введите описание" }),
    district: z.nativeEnum(Districts, { required_error: "Выберите район" }),
    city: z.string({ required_error: "Выберите город" }),
    contactName: z.string({ required_error: "Введите имя контакта" }),
    contactPrimaryPhone: z
      .string({ required_error: "Введите основной телефон" })
      .regex(/^[0-9]+$/, "Телефон может содержать только цифры"),
    contactSecondaryPhone: z
      .string()
      .regex(/^[0-9]+$/, "Телефон может содержать только цифры")
      .optional(),
    contactEmail: z
      .string({ required_error: "Электронная почта обязательна" })
      .email("Введите корректный адрес электронной почты"),
    acceptTerms: z
      .string()
      .optional()
      .superRefine((value, ctx) => {
        if (value === "on") return true;
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Вы должны согласиться с условиями",
          fatal: true,
        });
        return z.NEVER;
      }),
    images: z
      .array(z.instanceof(File))
      .min(minNumberOfImages, `Загрузите хотя бы ${minNumberOfImages} изображений`)
      .superRefine((files, ctx) => {
        const validFiles = files.filter(
          (file) => file.size > 0 && file.name !== "undefined"
        );
        if (validFiles.length > 0) {
          if (files.length > MAX_FILES) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Максимальное количество изображений: ${MAX_FILES}`,
              fatal: true,
            });
            return z.NEVER;
          }
          validFiles.forEach((file) => {
            if (file.size > MAX_FILE_SIZE) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Файл слишком большой. Максимальный размер: ${SIZE_IN_MB}MB`,
              });
            }
            if (!new Set(ACCEPTED_FILE_TYPES).has(file.type)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Файл должен быть изображением (PNG, JPEG, JPG или WebP)`,
                fatal: true,
              });
              return z.NEVER;
            }
          });
        }
        return true;
      }),
  });
};

export type MotorcycleFormData = z.infer<ReturnType<typeof createMotorcycleSchema>>;
```

### Mongoose Model (`lib/vehicles/motorcycles/models/Motorcycle.ts`)

```typescript
import { FileUploadItem } from "@/lib/files/uploadFiles";
import { MotorcycleCategory, MotorcycleEngineType } from "../types/motorcycle.types";
import mongoose from "mongoose";
import "@/lib/auth/models/User.ts";

export interface IMotorcycle {
  id: string;
  publicId: string;
  user: mongoose.Types.ObjectId;
  manufacturer: string;
  model: string;
  yearOfManufacture: number;
  engineDisplacement: number;
  engineType: MotorcycleEngineType;
  motorcycleCategory: MotorcycleCategory;
  mileage?: number;
  color?: string;
  hasABS: boolean;
  hasTractionControl?: boolean;
  numberOfCylinders?: number;
  accessories?: string;
  price: number;
  description: string;
  district: string;
  city: string;
  contactName: string;
  contactPrimaryPhone: string;
  contactSecondaryPhone?: string;
  contactEmail: string;
  acceptTerms: boolean;
  images: FileUploadItem[];
  createdAt?: Date;
  updatedAt?: Date;
}

const imageSchema = new mongoose.Schema(
  {
    originalName: { type: String, required: true },
    uniqueName: { type: String, required: true },
    url: { type: String, required: true },
    fieldname: { type: String, required: true },
    versionId: { type: String, required: false },
    folderName: { type: String, required: true },
  },
  {
    toJSON: {
      transform: (_doc, ret) => {
        ret.id = ret._id;
        delete ret._id;
      },
    },
  }
);

const motorcycleSchema = new mongoose.Schema(
  {
    publicId: { type: String, required: true, unique: true },
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    manufacturer: { type: String, required: true, index: true },
    model: { type: String, required: true, index: true },
    yearOfManufacture: { type: Number, required: true, min: 1900 },
    engineDisplacement: { type: Number, required: true, min: 1 },
    engineType: {
      type: String,
      required: true,
      enum: MotorcycleEngineType,
    },
    motorcycleCategory: {
      type: String,
      required: true,
      enum: MotorcycleCategory,
      index: true,
    },
    mileage: { type: Number, required: false, min: 0 },
    color: { type: String, required: false },
    hasABS: { type: Boolean, required: true, default: false },
    hasTractionControl: { type: Boolean, required: false, default: false },
    numberOfCylinders: { type: Number, required: false },
    accessories: { type: String, required: false },
    price: { type: Number, required: true, min: 0, index: true },
    description: { type: String, required: true },
    district: { type: String, required: true, index: true },
    city: { type: String, required: true, index: true },
    contactName: { type: String, required: true },
    contactPrimaryPhone: { type: String, required: true },
    contactSecondaryPhone: { type: String, required: false },
    contactEmail: { type: String, required: true, lowercase: true, trim: true },
    acceptTerms: { type: Boolean, required: true },
    images: { type: [imageSchema], required: true },
  },
  {
    timestamps: true,
    toJSON: {
      transform: (_doc, ret) => {
        ret.id = ret._id;
        ret.updatedAt = (ret.updatedAt as Date)?.toISOString();
        ret.createdAt = (ret.createdAt as Date)?.toISOString();
        delete ret._id;
        delete ret.__v;
      },
    },
  }
);

motorcycleSchema.index({
  description: "text",
  manufacturer: "text",
  model: "text",
});

export const Motorcycle =
  mongoose.models.Motorcycle || mongoose.model<IMotorcycle>("Motorcycle", motorcycleSchema);
```

### Repository (`lib/vehicles/motorcycles/repository/MotorcycleRepository.ts`)

```typescript
import { Motorcycle, IMotorcycle } from "../models/Motorcycle";
import connectDB from "@/lib/mongo/mongodb";
import { SerializedMotorcycle } from "../types/motorcycle.types";
import { FilterQuery } from "mongoose";
import mongoose from "mongoose";
import sanitize from "mongo-sanitize";

export interface MotorcycleSearchFilters {
  manufacturer?: string[];
  model?: string[];
  motorcycleCategory?: string[];
  yearFrom?: string;
  yearTo?: string;
  displacementFrom?: string;
  displacementTo?: string;
  district?: string[];
  city?: string[];
  priceFrom?: number;
  priceTo?: number;
  hasABS?: boolean;
}

interface PaginatedResponse {
  data: SerializedMotorcycle[];
  totalCount: number;
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

class MotorcycleRepository {
  async getAll(
    searchFilters: MotorcycleSearchFilters = {},
    currentPage: number = 1,
    pageSize: number = 10
  ): Promise<PaginatedResponse> {
    try {
      await connectDB();

      const sanitizedFilters: MotorcycleSearchFilters = {
        manufacturer: sanitize(searchFilters.manufacturer),
        model: sanitize(searchFilters.model),
        motorcycleCategory: sanitize(searchFilters.motorcycleCategory),
        yearFrom: sanitize(searchFilters.yearFrom),
        yearTo: sanitize(searchFilters.yearTo),
        displacementFrom: sanitize(searchFilters.displacementFrom),
        displacementTo: sanitize(searchFilters.displacementTo),
        district: sanitize(searchFilters.district),
        city: sanitize(searchFilters.city),
        priceFrom: sanitize(searchFilters.priceFrom),
        priceTo: sanitize(searchFilters.priceTo),
        hasABS: sanitize(searchFilters.hasABS),
      };

      const searchFilter: FilterQuery<typeof Motorcycle> = {};

      // Manufacturer filter
      if (sanitizedFilters.manufacturer) {
        searchFilter.manufacturer = { $in: sanitizedFilters.manufacturer };
      }

      // Model filter
      if (sanitizedFilters.model) {
        searchFilter.model = { $in: sanitizedFilters.model };
      }

      // Category filter
      if (sanitizedFilters.motorcycleCategory) {
        searchFilter.motorcycleCategory = { $in: sanitizedFilters.motorcycleCategory };
      }

      // Year range
      if (sanitizedFilters.yearFrom) {
        const yearFromNum = Number(sanitizedFilters.yearFrom);
        if (!Number.isNaN(yearFromNum)) {
          searchFilter.yearOfManufacture = { $gte: yearFromNum };
        }
      }
      if (sanitizedFilters.yearTo) {
        const yearToNum = Number(sanitizedFilters.yearTo);
        if (!Number.isNaN(yearToNum)) {
          searchFilter.yearOfManufacture = {
            ...searchFilter.yearOfManufacture,
            $lte: yearToNum,
          };
        }
      }

      // Displacement range
      if (sanitizedFilters.displacementFrom) {
        const dispFromNum = Number(sanitizedFilters.displacementFrom);
        if (!Number.isNaN(dispFromNum)) {
          searchFilter.engineDisplacement = { $gte: dispFromNum };
        }
      }
      if (sanitizedFilters.displacementTo) {
        const dispToNum = Number(sanitizedFilters.displacementTo);
        if (!Number.isNaN(dispToNum)) {
          searchFilter.engineDisplacement = {
            ...searchFilter.engineDisplacement,
            $lte: dispToNum,
          };
        }
      }

      // District filter
      if (sanitizedFilters.district) {
        searchFilter.district = { $in: sanitizedFilters.district };
      }

      // City filter
      if (sanitizedFilters.city) {
        searchFilter.city = { $in: sanitizedFilters.city };
      }

      // Price range
      if (sanitizedFilters.priceFrom !== undefined) {
        const priceFromNum = Number(sanitizedFilters.priceFrom);
        if (!Number.isNaN(priceFromNum) && priceFromNum >= 0) {
          searchFilter.price = { $gte: priceFromNum };
        }
      }
      if (sanitizedFilters.priceTo !== undefined) {
        const priceToNum = Number(sanitizedFilters.priceTo);
        if (!Number.isNaN(priceToNum) && priceToNum >= 0) {
          searchFilter.price = { ...searchFilter.price, $lte: priceToNum };
        }
      }

      // ABS filter
      if (sanitizedFilters.hasABS !== undefined) {
        searchFilter.hasABS = sanitizedFilters.hasABS;
      }

      const skip = (currentPage - 1) * pageSize;
      const totalCount = await Motorcycle.countDocuments(searchFilter);
      const totalPages = Math.ceil(totalCount / pageSize);

      const motorcycles = await Motorcycle.find(searchFilter)
        .populate("user")
        .sort({ createdAt: -1, _id: -1 })
        .skip(skip)
        .limit(pageSize);

      const serialized = JSON.parse(JSON.stringify(motorcycles));

      return {
        data: serialized,
        totalCount,
        currentPage,
        totalPages,
        hasNextPage: currentPage < totalPages,
        hasPreviousPage: currentPage > 1,
      };
    } catch (error) {
      console.error("Error fetching motorcycles:", error);
      throw new Error("Failed to fetch motorcycles");
    }
  }

  async getByPublicId(publicId: string): Promise<SerializedMotorcycle | null> {
    try {
      await connectDB();
      const motorcycle = await Motorcycle.findOne({ publicId }).populate("user");
      if (!motorcycle) return null;
      return JSON.parse(JSON.stringify(motorcycle));
    } catch (error) {
      console.error("Error fetching motorcycle:", error);
      throw new Error("Failed to fetch motorcycle");
    }
  }

  async create(data: Omit<IMotorcycle, "id" | "createdAt" | "updatedAt">): Promise<SerializedMotorcycle> {
    try {
      await connectDB();
      const motorcycle = new Motorcycle(data);
      await motorcycle.save();
      await motorcycle.populate("user");
      return JSON.parse(JSON.stringify(motorcycle));
    } catch (error) {
      console.error("Error creating motorcycle:", error);
      throw new Error("Failed to create motorcycle");
    }
  }

  async edit(publicId: string, updateData: Partial<IMotorcycle>): Promise<SerializedMotorcycle | null> {
    try {
      await connectDB();
      const motorcycle = await Motorcycle.findOneAndUpdate(
        { publicId },
        { ...updateData },
        { new: true, runValidators: true }
      ).populate("user");
      if (!motorcycle) return null;
      await motorcycle.save();
      return JSON.parse(JSON.stringify(motorcycle));
    } catch (error) {
      console.error("Error updating motorcycle:", error);
      throw new Error("Failed to update motorcycle");
    }
  }

  async delete(publicId: string): Promise<boolean> {
    try {
      await connectDB();
      const result = await Motorcycle.findOneAndDelete({ publicId });
      return result !== null;
    } catch (error) {
      console.error("Error deleting motorcycle:", error);
      throw new Error("Failed to delete motorcycle");
    }
  }
}

export const motorcycleRepository = new MotorcycleRepository();
```

---

## Example Schema: Accessories (Simple Category)

Accessories don't have manufacturer/model relationships - they use categories instead.

### Types (`lib/vehicles/accessories/types/accessory.types.ts`)

```typescript
import { SerializedUser } from "@/lib/auth/types/auth.schema";
import { FileUploadItem } from "@/lib/files/uploadFiles";
import mongoose from "mongoose";

// Accessory-specific enums
export enum AccessoryCategory {
  AUDIO = "audio",
  EXTERIOR = "exterior",
  INTERIOR = "interior",
  PERFORMANCE = "performance",
  LIGHTING = "lighting",
  WHEELS_TIRES = "wheelsTires",
  SAFETY = "safety",
  ELECTRONICS = "electronics",
  MAINTENANCE = "maintenance",
  OTHER = "other",
}

export enum AccessoryCondition {
  NEW = "new",
  USED = "used",
  REFURBISHED = "refurbished",
}

export interface IAccessory {
  id: string;
  publicId: string;
  user: mongoose.Types.ObjectId;
  title: string;                         // Required - item name
  accessoryCategory: AccessoryCategory;  // Required
  subcategory?: string;                  // Optional - freeform text
  condition: AccessoryCondition;         // Required
  brand?: string;                        // Optional
  compatibleVehicles?: string;           // Optional - text description
  price: number;
  description: string;
  district: string;
  city: string;
  contactName: string;
  contactPrimaryPhone: string;
  contactSecondaryPhone?: string;
  contactEmail: string;
  acceptTerms: boolean;
  images: FileUploadItem[];
  createdAt?: Date;
  updatedAt?: Date;
}

export interface SerializedAccessory
  extends Omit<IAccessory, "createdAt" | "updatedAt" | "user"> {
  updatedAt: string;
  createdAt: string;
  user: SerializedUser;
}
```

### Zod Schema (`lib/vehicles/accessories/types/accessory.schema.ts`)

```typescript
import { z } from "zod";
import { Districts } from "@/lib/cities/types/cities.schema";
import { AccessoryCategory, AccessoryCondition } from "./accessory.types";

export const SIZE_IN_MB = 5;
export const MAX_FILE_SIZE = SIZE_IN_MB * 1024 * 1024;
export const MAX_FILES = 5;

export const ACCEPTED_FILE_TYPES = [
  "image/png",
  "image/jpeg",
  "image/jpg",
  "image/webp",
];

export const createAccessorySchema = ({ minNumberOfImages = 1 }) => {
  return z.object({
    // Accessory-specific fields
    title: z.string({ required_error: "Введите название товара" })
      .min(3, "Название должно содержать минимум 3 символа"),
    accessoryCategory: z.nativeEnum(AccessoryCategory, {
      required_error: "Выберите категорию",
    }),
    subcategory: z.string().optional(),
    condition: z.nativeEnum(AccessoryCondition, {
      required_error: "Выберите состояние",
    }),
    brand: z.string().optional(),
    compatibleVehicles: z.string().optional(),
    
    // Base fields
    price: z
      .string({ required_error: "Введите цену" })
      .refine((val) => /^-?\d[\d,]*$/.test(val), {
        message: "Цена должна быть числом.",
      })
      .transform((val) => Number(val.replace(/,/g, ""))),
    description: z.string({ required_error: "Введите описание" }),
    district: z.nativeEnum(Districts, { required_error: "Выберите район" }),
    city: z.string({ required_error: "Выберите город" }),
    contactName: z.string({ required_error: "Введите имя контакта" }),
    contactPrimaryPhone: z
      .string({ required_error: "Введите основной телефон" })
      .regex(/^[0-9]+$/, "Телефон может содержать только цифры"),
    contactSecondaryPhone: z
      .string()
      .regex(/^[0-9]+$/, "Телефон может содержать только цифры")
      .optional(),
    contactEmail: z
      .string({ required_error: "Электронная почта обязательна" })
      .email("Введите корректный адрес электронной почты"),
    acceptTerms: z
      .string()
      .optional()
      .superRefine((value, ctx) => {
        if (value === "on") return true;
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Вы должны согласиться с условиями",
          fatal: true,
        });
        return z.NEVER;
      }),
    images: z
      .array(z.instanceof(File))
      .min(minNumberOfImages, `Загрузите хотя бы ${minNumberOfImages} изображений`)
      .superRefine((files, ctx) => {
        const validFiles = files.filter(
          (file) => file.size > 0 && file.name !== "undefined"
        );
        if (validFiles.length > MAX_FILES) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Максимальное количество изображений: ${MAX_FILES}`,
            fatal: true,
          });
          return z.NEVER;
        }
        validFiles.forEach((file) => {
          if (file.size > MAX_FILE_SIZE) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Файл слишком большой. Максимальный размер: ${SIZE_IN_MB}MB`,
            });
          }
          if (!new Set(ACCEPTED_FILE_TYPES).has(file.type)) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Файл должен быть изображением`,
              fatal: true,
            });
            return z.NEVER;
          }
        });
        return true;
      }),
  });
};

export type AccessoryFormData = z.infer<ReturnType<typeof createAccessorySchema>>;
```

### Filters for Accessories

Since accessories don't have manufacturer/model, filters are simpler:

```typescript
export interface AccessorySearchFilters {
  accessoryCategory?: string[];
  condition?: string[];
  district?: string[];
  city?: string[];
  priceFrom?: number;
  priceTo?: number;
  brand?: string;  // Text search
}
```

---

## Step-by-Step Implementation Checklist

Use this checklist when implementing a new vehicle category:

### Phase 1: Data Layer

- [ ] **1.1** Create types file (`lib/vehicles/{category}/types/{entity}.types.ts`)
  - Define entity-specific enums (e.g., `MotorcycleCategory`, `AccessoryCondition`)
  - Define `I{Entity}` interface extending base fields
  - Define `Serialized{Entity}` type for client-side use

- [ ] **1.2** Create Zod schema (`lib/vehicles/{category}/types/{entity}.schema.ts`)
  - Define file upload constants (`MAX_FILE_SIZE`, `MAX_FILES`)
  - Create `create{Entity}Schema({ minNumberOfImages })` function
  - Include all entity-specific and base validation fields
  - Export `{Entity}FormData` type

- [ ] **1.3** Create Mongoose model (`lib/vehicles/{category}/models/{Entity}.ts`)
  - Import `FileUploadItem` from `@/lib/files/uploadFiles`
  - Define `imageSchema` for embedded images
  - Define `{entity}Schema` with all fields and indexes
  - Export model with singleton pattern

- [ ] **1.4** Create repository (`lib/vehicles/{category}/repository/{Entity}Repository.ts`)
  - Define `{Entity}SearchFilters` interface
  - Implement `getAll(filters, page, pageSize)` with sanitization
  - Implement `getByPublicId(publicId)`
  - Implement `create(data)`
  - Implement `edit(publicId, updateData)`
  - Implement `delete(publicId)`
  - Export singleton instance

### Phase 2: Static Data (If Manufacturer/Model Required)

- [ ] **2.1** Create manufacturer schema (`lib/vehicles/{category}/{category}Manufacturers/types/{entity}Manufacturer.schema.ts`)
  - Define `{Entity}Model` interface
  - Define `{Entity}Manufacturer` interface
  - Export type aliases

- [ ] **2.2** Create manufacturer data (`lib/vehicles/{category}/{category}Manufacturers/data.ts`)
  - Define all manufacturers with their models
  - Use `satisfies Record<ManufacturerId, Manufacturer>` for type safety

- [ ] **2.3** Create manufacturer utilities (`lib/vehicles/{category}/{category}Manufacturers/index.ts`)
  - Export `map{Entity}ManufacturersToSelectOptions()`
  - Export caching utilities

- [ ] **2.4** Create model utilities (`lib/vehicles/{category}/{category}Models/index.ts`)
  - Export `get{Entity}ModelsToSelectOptions(manufacturerId)`
  - Export `get{Entity}ModelsToSelectOptionsByManufacturerIds(ids)`

### Phase 3: Server Actions

- [ ] **3.1** Create publish action (`lib/vehicles/{category}/actions/publish{Entity}Ad.ts`)
  - Parse form data with Zod schema
  - Get current user
  - Upload files to `vehicles/{category}` folder
  - Create entity via repository
  - Revalidate and redirect

- [ ] **3.2** Create edit action (`lib/vehicles/{category}/actions/edit{Entity}Ad.ts`)
  - Accept context with `publicId`, `imagesToDelete`, `allImagesShouldBeDeleted`
  - Handle image deletion before uploading new ones
  - Merge existing and new images
  - Update via repository

- [ ] **3.3** Create delete action (`lib/vehicles/{category}/actions/delete{Entity}Ad.ts`)
  - Verify user authentication and ownership
  - Delete images from storage
  - Delete entity via repository
  - Create version with redirect

- [ ] **3.4** Create actions index (`lib/vehicles/{category}/actions/index.ts`)
  - Export all actions

### Phase 4: Publish Form

- [ ] **4.1** Create form component (`app/(private)/publish-ad/_components/vehicles/{Entity}PublishForm/{Entity}PublishForm.tsx`)
  - Accept `entity?: Serialized{Entity}` and `formMode: FormMode` props
  - Use `useForm` with `@conform-to/react`
  - Handle existing images state for edit mode
  - Implement all form sections (entity-specific, price, location, photos, contact)
  - Use `SelectSingle` for dropdowns, `BasicFormField` for inputs
  - Use `PriceFormField` for price, `PhoneFormField` for phones
  - Use `DropFilesInput` and `ImagesPreviewer` for images

- [ ] **4.2** Create form styles (`app/(private)/publish-ad/_components/vehicles/{Entity}PublishForm/{Entity}PublishForm.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)
  - Copy from `CarPublishForm.styles.ts`

- [ ] **4.3** Create create page (`app/(private)/publish-ad/vehicles/{category}/[formMode]/page.tsx`)
  - Validate `formMode` with schema
  - Return `notFound()` if `formMode === FormMode.Edit`
  - Render form with `FormMode.Create`

- [ ] **4.4** Create edit page (`app/(private)/publish-ad/vehicles/{category}/[formMode]/[id]/page.tsx`)
  - Validate `formMode` with schema
  - Return `notFound()` if `formMode === FormMode.Create`
  - Fetch entity by publicId
  - Verify ownership with `thisUserIsOwner`
  - Render form with `FormMode.Edit` and entity data

- [ ] **4.5** Create page styles (`app/(private)/publish-ad/vehicles/{category}/[formMode]/page.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)

### Phase 5: Listing Page

**⚠️ IMPORTANT: Create Phase 6 (Filters) BEFORE or AT THE SAME TIME as Phase 5.1, since the page imports Filters component. If you create the page first, you'll get a "Module not found" error.**

- [ ] **5.1** Create page (`app/(public)/vehicles/{category}/page.tsx`)
  - **⚠️ CRITICAL: Ensure Filters component exists (Phase 6.1) before importing it here**
  - Define `searchParams` interface with filter params
  - Extract and process filters using `searchParamsToFilters`
  - Create `contentKey` for Suspense
  - Render `Filters` and `Content` in Suspense

- [ ] **5.2** Create page styles (`app/(public)/vehicles/{category}/page.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)
  - Define `{Category}PageContainer`, `{Entity}Grid`, `StickyPaginationWrapper`, `Title`

- [ ] **5.3** Create loading component (`app/(public)/vehicles/{category}/loading.tsx`)
  - Render skeleton cards (6 by default)

- [ ] **5.4** Create loading styles (`app/(public)/vehicles/{category}/loading.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)

- [ ] **5.5** Create content component (`app/(public)/vehicles/{category}/_components/{Entity}Content/{Entity}Content.tsx`)
  - Fetch data with `repository.getAll(filters, currentPage, pageSize)`
  - Render title, results count, grid of cards, pagination

- [ ] **5.6** Create card component (`app/(public)/vehicles/{category}/_components/{Entity}Cards/{Entity}Card.tsx`)
  - Display image carousel, title, key specs, price, location
  - Use appropriate formatting helpers

- [ ] **5.7** Create card styles (`app/(public)/vehicles/{category}/_components/{Entity}Cards/{Entity}Card.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)

- [ ] **5.8** Create cards list (`app/(public)/vehicles/{category}/_components/{Entity}Cards/{Entity}Cards.tsx`)
  - Map entities to Link + Card components

### Phase 6: Filters

**⚠️ IMPORTANT: Create this phase BEFORE or AT THE SAME TIME as Phase 5.1, since the listing page imports the Filters component.**

- [ ] **6.1** Create filters wrapper (`app/(public)/vehicles/{category}/_components/Filters/Filters.tsx`)
  - Use `VehicleFilters` wrapper component
  - Pass `activeFiltersCount` from searchParams

- [ ] **6.2** Create filters client (`app/(public)/vehicles/{category}/_components/Filters/FiltersClient.tsx`)
  - Define `allSelectedFilterOptions` Map state with all filter params
  - Define `moreFilters` state for text inputs (price, etc.)
  - Implement `handleSubmitAllFilters`, `handleSetAllSelectedFilterOptions`, `handleClearFilters`
  - Use `SearchMultiSelect` for multi-select filters
  - Use `SearchSingleSelect` for single-select filters (year, etc.)
  - Use `DialogPrimitiveButton` to group related filters
  - Use `PriceTextSearch` for price range
  - Render desktop and mobile filter layouts

- [ ] **6.3** Create filters types (`app/(public)/vehicles/{category}/_components/Filters/filters.types.ts`)
  - Define Zod schema for text input validation
  - Import `PriceFromToSchema` from common types

- [ ] **6.4** Create filters utils (`app/(public)/vehicles/{category}/_components/Filters/Filters.utils.ts`)
  - Helper functions for filter button titles

- [ ] **6.5** Create filters styles (`app/(public)/vehicles/{category}/_components/Filters/Filters.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)

- [ ] **6.6** Create more filters modal (`app/(public)/vehicles/{category}/_components/modals/MoreFiltersModal/`)
  - Modal for additional filters (district, city, price, etc.)
  - **Add `"use client"` directive at the top of `.styles.ts` file** (required for styled-components)

### Phase 7: Detail Page

- [ ] **7.1** Create detail page (`app/(public)/vehicles/{category}/[id]/page.tsx`)
  - Fetch entity by publicId
  - Return `notFound()` if not found
  - Render detail client component

- [ ] **7.2** Create detail client (`app/(public)/vehicles/{category}/_components/{Entity}DetailClient/{Entity}DetailClient.tsx`)
  - Display image gallery with modal
  - Display all entity information sections
  - Display contact information (mask email, show phone for authenticated users)
  - Owner actions: Edit button (link), Delete button with confirmation modal
  - Error modal for delete errors

- [ ] **7.3** Create detail styles (`app/(public)/vehicles/{category}/_components/{Entity}DetailClient/{Entity}DetailClient.styles.ts`)
  - **Add `"use client"` directive at the top** (required for styled-components)

### Phase 8: Integration

- [ ] **8.1** Update VehicleFilters navigation (`app/(public)/vehicles/_components/Filters/VehicleFilters/VehicleFilters.tsx`)
  - Add category to `vehicleCategories` array with correct `href`

- [ ] **8.2** Update publish-ad categories page (`app/(private)/publish-ad/vehicles/page.tsx`)
  - Verify category is in `vehicleCategories` array with correct `href`

---

## Key Code Patterns Reference

### File Upload Pattern

```typescript
// In publish action
const uploadResult = await uploadFiles(
  "vehicles/{category}",  // Folder path
  user.id,                // User ID
  uploadFormData          // FormData with 'files' field
);
```

### Repository Filter Pattern

```typescript
// Always sanitize incoming filters
const sanitizedFilters = {
  field: sanitize(searchFilters.field),
};

// Build MongoDB query
const searchFilter: FilterQuery<typeof Entity> = {};

// Multi-value filter
if (sanitizedFilters.field) {
  searchFilter.field = { $in: sanitizedFilters.field };
}

// Range filter
if (sanitizedFilters.valueFrom) {
  const num = Number(sanitizedFilters.valueFrom);
  if (!Number.isNaN(num)) {
    searchFilter.numericField = { $gte: num };
  }
}
```

### Form Create/Edit Mode Pattern

```typescript
// Form component accepts mode and optional entity
interface FormProps {
  entity?: SerializedEntity;
  formMode: FormMode;
}

// Check mode
const isCreateMode = formMode === FormMode.Create;

// Use appropriate action
const [formState, formAction, isPending] = useActionState(
  isCreateMode ? publishEntityAd : updateEntityWithImagesToDelete,
  undefined
);

// Populate defaults from entity in edit mode
const [form, fields] = useForm({
  defaultValue: {
    field: entity?.field || "",
    // ...
  },
});
```

### Detail Page Owner Actions Pattern

```typescript
const { user: currentUser, thisUserIsOwner } = useAuth();
const isOwner = thisUserIsOwner(entity.user.id);

// Conditionally render edit/delete buttons
{isOwner && (
  <ButtonGroup>
    <Button asChild>
      <Link href={`/publish-ad/vehicles/{category}/edit/${publicId}`}>
        Редактировать
      </Link>
    </Button>
    <Button onClick={() => setDeleteConfirmationModalOpen(true)}>
      Удалить
    </Button>
  </ButtonGroup>
)}
```

---

## Category-Specific Notes

### Cars (Existing - Reference Implementation)

- **Files**: `lib/vehicles/cars/`
- **Manufacturers**: 26,000+ lines in `vehicleManufacturers/data.ts`
- **Unique Fields**: `transmission`, `engineType`, `engineCapacity`, `mileage`, `numberOfDoors`, `numberOfHand`, `color`, `accessories`

### Off-Road

- Can potentially share car manufacturers data or have separate list
- **Unique Fields**: `driveType` (4x4/AWD/2WD), `groundClearance`, `offRoadFeatures`
- Consider adding: `wheelSize`, `suspensionType`, `hasDiffLock`

### Commercial Vehicles

- Has separate commercial vehicle manufacturers list (e.g., OPEL with models like Vivaro, Movano, Combo)
- **Unique Fields**: `transmission` (reuses `TransmissionType` from cars), `numberOfHand`, `mileage`, `numberOfDoors`, `color`
- **NOT included**: `engineType`, `engineCapacity`, `accessories` (unlike cars)
- **URL path**: `/vehicles/commercial-vehicles`
- Similar to cars but for commercial vehicles (vans, light commercial vehicles)

### Motorcycles

- Needs motorcycle manufacturers list (different from cars)
- **Unique Fields**: `engineDisplacement`, `motorcycleCategory`, `hasABS`, `hasTractionControl`
- See example implementation above

### Scooters

- Simpler manufacturer list than motorcycles
- **Unique Fields**: `engineDisplacement`, `powerType` (electric/gas)
- Consider adding: `maxSpeed`, `range` (for electric)

### ATV

- Needs ATV manufacturers list
- **Unique Fields**: `engineDisplacement`, `terrainType`, `seating` (single/double)
- Consider adding: `driveType`, `hasWindshield`

### Trailers

- No manufacturer/model needed
- **Unique Fields**: `trailerType`, `capacity`, `axles`, `brakeType`
- Consider adding: `length`, `width`, `hasRamp`, `hasSideLoading`

### Accessories

- No manufacturer/model needed
- **Unique Fields**: `title`, `accessoryCategory`, `condition`, `brand`
- See example implementation above
- Filters are simpler (category, condition, price)

---

## URL Patterns

| Action | URL Pattern |
|--------|-------------|
| Category selection (publish) | `/publish-ad/vehicles` |
| Create ad | `/publish-ad/vehicles/{category}/create` |
| Edit ad | `/publish-ad/vehicles/{category}/edit/{publicId}` |
| View listings | `/vehicles/{category}` |
| View detail | `/vehicles/{category}/{publicId}` |

---

## Common Utilities

### Location

```typescript
import { mapAreasToSelectOptions, getCitiesToSelectOptions } from "@/lib/cities";
import { Districts } from "@/lib/cities/types/cities.schema";
```

### Years/Numbers

```typescript
import { getYearsOptions, getNumberOfHandsOptions, getNumberOfDorsOptions } from "@/lib/vehicles/utils/vehicles.utils";
```

### Price Formatting

```typescript
const formatPrice = (price: number): string => {
  return new Intl.NumberFormat("il-IL", { 
    style: "currency", 
    currency: "ILS" 
  }).format(price);
};
```

### Date Formatting

```typescript
const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString("ru-RU", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
};
```
